/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * NET_Messages enum.
     * @exports NET_Messages
     * @enum {string}
     * @property {number} net_NOP=0 net_NOP value
     * @property {number} net_Disconnect=1 net_Disconnect value
     * @property {number} net_File=2 net_File value
     * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
     * @property {number} net_Tick=4 net_Tick value
     * @property {number} net_StringCmd=5 net_StringCmd value
     * @property {number} net_SetConVar=6 net_SetConVar value
     * @property {number} net_SignonState=7 net_SignonState value
     * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value
     */
    $root.NET_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "net_NOP"] = 0;
        values[valuesById[1] = "net_Disconnect"] = 1;
        values[valuesById[2] = "net_File"] = 2;
        values[valuesById[3] = "net_SplitScreenUser"] = 3;
        values[valuesById[4] = "net_Tick"] = 4;
        values[valuesById[5] = "net_StringCmd"] = 5;
        values[valuesById[6] = "net_SetConVar"] = 6;
        values[valuesById[7] = "net_SignonState"] = 7;
        values[valuesById[100] = "net_PlayerAvatarData"] = 100;
        return values;
    })();
    
    /**
     * CLC_Messages enum.
     * @exports CLC_Messages
     * @enum {string}
     * @property {number} clc_ClientInfo=8 clc_ClientInfo value
     * @property {number} clc_Move=9 clc_Move value
     * @property {number} clc_VoiceData=10 clc_VoiceData value
     * @property {number} clc_BaselineAck=11 clc_BaselineAck value
     * @property {number} clc_ListenEvents=12 clc_ListenEvents value
     * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value
     * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value
     * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value
     * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value
     * @property {number} clc_ClientMessage=17 clc_ClientMessage value
     * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value
     * @property {number} clc_HltvReplay=20 clc_HltvReplay value
     */
    $root.CLC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[8] = "clc_ClientInfo"] = 8;
        values[valuesById[9] = "clc_Move"] = 9;
        values[valuesById[10] = "clc_VoiceData"] = 10;
        values[valuesById[11] = "clc_BaselineAck"] = 11;
        values[valuesById[12] = "clc_ListenEvents"] = 12;
        values[valuesById[13] = "clc_RespondCvarValue"] = 13;
        values[valuesById[14] = "clc_FileCRCCheck"] = 14;
        values[valuesById[15] = "clc_LoadingProgress"] = 15;
        values[valuesById[16] = "clc_SplitPlayerConnect"] = 16;
        values[valuesById[17] = "clc_ClientMessage"] = 17;
        values[valuesById[18] = "clc_CmdKeyValues"] = 18;
        values[valuesById[20] = "clc_HltvReplay"] = 20;
        return values;
    })();
    
    /**
     * VoiceDataFormat_t enum.
     * @exports VoiceDataFormat_t
     * @enum {string}
     * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
     * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
     */
    $root.VoiceDataFormat_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VOICEDATA_FORMAT_STEAM"] = 0;
        values[valuesById[1] = "VOICEDATA_FORMAT_ENGINE"] = 1;
        return values;
    })();
    
    /**
     * ESplitScreenMessageType enum.
     * @exports ESplitScreenMessageType
     * @enum {string}
     * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
     * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
     * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value
     */
    $root.ESplitScreenMessageType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MSG_SPLITSCREEN_ADDUSER"] = 0;
        values[valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER"] = 1;
        values["MSG_SPLITSCREEN_TYPE_BITS"] = 1;
        return values;
    })();
    
    /**
     * SVC_Messages enum.
     * @exports SVC_Messages
     * @enum {string}
     * @property {number} svc_ServerInfo=8 svc_ServerInfo value
     * @property {number} svc_SendTable=9 svc_SendTable value
     * @property {number} svc_ClassInfo=10 svc_ClassInfo value
     * @property {number} svc_SetPause=11 svc_SetPause value
     * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value
     * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value
     * @property {number} svc_VoiceInit=14 svc_VoiceInit value
     * @property {number} svc_VoiceData=15 svc_VoiceData value
     * @property {number} svc_Print=16 svc_Print value
     * @property {number} svc_Sounds=17 svc_Sounds value
     * @property {number} svc_SetView=18 svc_SetView value
     * @property {number} svc_FixAngle=19 svc_FixAngle value
     * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value
     * @property {number} svc_BSPDecal=21 svc_BSPDecal value
     * @property {number} svc_SplitScreen=22 svc_SplitScreen value
     * @property {number} svc_UserMessage=23 svc_UserMessage value
     * @property {number} svc_EntityMessage=24 svc_EntityMessage value
     * @property {number} svc_GameEvent=25 svc_GameEvent value
     * @property {number} svc_PacketEntities=26 svc_PacketEntities value
     * @property {number} svc_TempEntities=27 svc_TempEntities value
     * @property {number} svc_Prefetch=28 svc_Prefetch value
     * @property {number} svc_Menu=29 svc_Menu value
     * @property {number} svc_GameEventList=30 svc_GameEventList value
     * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value
     * @property {number} svc_PaintmapData=33 svc_PaintmapData value
     * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value
     * @property {number} svc_EncryptedData=35 svc_EncryptedData value
     * @property {number} svc_HltvReplay=36 svc_HltvReplay value
     * @property {number} svc_Broadcast_Command=38 svc_Broadcast_Command value
     */
    $root.SVC_Messages = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[8] = "svc_ServerInfo"] = 8;
        values[valuesById[9] = "svc_SendTable"] = 9;
        values[valuesById[10] = "svc_ClassInfo"] = 10;
        values[valuesById[11] = "svc_SetPause"] = 11;
        values[valuesById[12] = "svc_CreateStringTable"] = 12;
        values[valuesById[13] = "svc_UpdateStringTable"] = 13;
        values[valuesById[14] = "svc_VoiceInit"] = 14;
        values[valuesById[15] = "svc_VoiceData"] = 15;
        values[valuesById[16] = "svc_Print"] = 16;
        values[valuesById[17] = "svc_Sounds"] = 17;
        values[valuesById[18] = "svc_SetView"] = 18;
        values[valuesById[19] = "svc_FixAngle"] = 19;
        values[valuesById[20] = "svc_CrosshairAngle"] = 20;
        values[valuesById[21] = "svc_BSPDecal"] = 21;
        values[valuesById[22] = "svc_SplitScreen"] = 22;
        values[valuesById[23] = "svc_UserMessage"] = 23;
        values[valuesById[24] = "svc_EntityMessage"] = 24;
        values[valuesById[25] = "svc_GameEvent"] = 25;
        values[valuesById[26] = "svc_PacketEntities"] = 26;
        values[valuesById[27] = "svc_TempEntities"] = 27;
        values[valuesById[28] = "svc_Prefetch"] = 28;
        values[valuesById[29] = "svc_Menu"] = 29;
        values[valuesById[30] = "svc_GameEventList"] = 30;
        values[valuesById[31] = "svc_GetCvarValue"] = 31;
        values[valuesById[33] = "svc_PaintmapData"] = 33;
        values[valuesById[34] = "svc_CmdKeyValues"] = 34;
        values[valuesById[35] = "svc_EncryptedData"] = 35;
        values[valuesById[36] = "svc_HltvReplay"] = 36;
        values[valuesById[38] = "svc_Broadcast_Command"] = 38;
        return values;
    })();
    
    /**
     * ReplayEventType_t enum.
     * @exports ReplayEventType_t
     * @enum {string}
     * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value
     * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value
     * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value
     * @property {number} REPLAY_EVENT_STUCK_NEED_FULL_UPDATE=3 REPLAY_EVENT_STUCK_NEED_FULL_UPDATE value
     */
    $root.ReplayEventType_t = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REPLAY_EVENT_CANCEL"] = 0;
        values[valuesById[1] = "REPLAY_EVENT_DEATH"] = 1;
        values[valuesById[2] = "REPLAY_EVENT_GENERIC"] = 2;
        values[valuesById[3] = "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE"] = 3;
        return values;
    })();
    
    $root.CMsgVector = (function() {
    
        /**
         * Properties of a CMsgVector.
         * @exports ICMsgVector
         * @interface ICMsgVector
         * @property {number|null} [x] CMsgVector x
         * @property {number|null} [y] CMsgVector y
         * @property {number|null} [z] CMsgVector z
         */
    
        /**
         * Constructs a new CMsgVector.
         * @exports CMsgVector
         * @classdesc Represents a CMsgVector.
         * @implements ICMsgVector
         * @constructor
         * @param {ICMsgVector=} [properties] Properties to set
         */
        function CMsgVector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector x.
         * @member {number} x
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.x = 0;
    
        /**
         * CMsgVector y.
         * @member {number} y
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.y = 0;
    
        /**
         * CMsgVector z.
         * @member {number} z
         * @memberof CMsgVector
         * @instance
         */
        CMsgVector.prototype.z = 0;
    
        /**
         * Creates a new CMsgVector instance using the specified properties.
         * @function create
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector=} [properties] Properties to set
         * @returns {CMsgVector} CMsgVector instance
         */
        CMsgVector.create = function create(properties) {
            return new CMsgVector(properties);
        };
    
        /**
         * Encodes the specified CMsgVector message. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && message.hasOwnProperty("z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector message, length delimited. Does not implicitly {@link CMsgVector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {ICMsgVector} message CMsgVector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector} CMsgVector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector message.
         * @function verify
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector} CMsgVector
         */
        CMsgVector.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector)
                return object;
            var message = new $root.CMsgVector();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector
         * @static
         * @param {CMsgVector} message CMsgVector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgVector to JSON.
         * @function toJSON
         * @memberof CMsgVector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector;
    })();
    
    $root.CMsgVector2D = (function() {
    
        /**
         * Properties of a CMsgVector2D.
         * @exports ICMsgVector2D
         * @interface ICMsgVector2D
         * @property {number|null} [x] CMsgVector2D x
         * @property {number|null} [y] CMsgVector2D y
         */
    
        /**
         * Constructs a new CMsgVector2D.
         * @exports CMsgVector2D
         * @classdesc Represents a CMsgVector2D.
         * @implements ICMsgVector2D
         * @constructor
         * @param {ICMsgVector2D=} [properties] Properties to set
         */
        function CMsgVector2D(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgVector2D x.
         * @member {number} x
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.x = 0;
    
        /**
         * CMsgVector2D y.
         * @member {number} y
         * @memberof CMsgVector2D
         * @instance
         */
        CMsgVector2D.prototype.y = 0;
    
        /**
         * Creates a new CMsgVector2D instance using the specified properties.
         * @function create
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D=} [properties] Properties to set
         * @returns {CMsgVector2D} CMsgVector2D instance
         */
        CMsgVector2D.create = function create(properties) {
            return new CMsgVector2D(properties);
        };
    
        /**
         * Encodes the specified CMsgVector2D message. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encode
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgVector2D message, length delimited. Does not implicitly {@link CMsgVector2D.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {ICMsgVector2D} message CMsgVector2D message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgVector2D.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgVector2D message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgVector2D
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgVector2D} CMsgVector2D
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgVector2D.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgVector2D message.
         * @function verify
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgVector2D.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgVector2D message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgVector2D
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgVector2D} CMsgVector2D
         */
        CMsgVector2D.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgVector2D)
                return object;
            var message = new $root.CMsgVector2D();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgVector2D message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgVector2D
         * @static
         * @param {CMsgVector2D} message CMsgVector2D
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgVector2D.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };
    
        /**
         * Converts this CMsgVector2D to JSON.
         * @function toJSON
         * @memberof CMsgVector2D
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgVector2D.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgVector2D;
    })();
    
    $root.CMsgQAngle = (function() {
    
        /**
         * Properties of a CMsgQAngle.
         * @exports ICMsgQAngle
         * @interface ICMsgQAngle
         * @property {number|null} [x] CMsgQAngle x
         * @property {number|null} [y] CMsgQAngle y
         * @property {number|null} [z] CMsgQAngle z
         */
    
        /**
         * Constructs a new CMsgQAngle.
         * @exports CMsgQAngle
         * @classdesc Represents a CMsgQAngle.
         * @implements ICMsgQAngle
         * @constructor
         * @param {ICMsgQAngle=} [properties] Properties to set
         */
        function CMsgQAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgQAngle x.
         * @member {number} x
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.x = 0;
    
        /**
         * CMsgQAngle y.
         * @member {number} y
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.y = 0;
    
        /**
         * CMsgQAngle z.
         * @member {number} z
         * @memberof CMsgQAngle
         * @instance
         */
        CMsgQAngle.prototype.z = 0;
    
        /**
         * Creates a new CMsgQAngle instance using the specified properties.
         * @function create
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle=} [properties] Properties to set
         * @returns {CMsgQAngle} CMsgQAngle instance
         */
        CMsgQAngle.create = function create(properties) {
            return new CMsgQAngle(properties);
        };
    
        /**
         * Encodes the specified CMsgQAngle message. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encode
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && message.hasOwnProperty("x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && message.hasOwnProperty("y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && message.hasOwnProperty("z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgQAngle message, length delimited. Does not implicitly {@link CMsgQAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {ICMsgQAngle} message CMsgQAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgQAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgQAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgQAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgQAngle} CMsgQAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgQAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgQAngle message.
         * @function verify
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgQAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };
    
        /**
         * Creates a CMsgQAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgQAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgQAngle} CMsgQAngle
         */
        CMsgQAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgQAngle)
                return object;
            var message = new $root.CMsgQAngle();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgQAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgQAngle
         * @static
         * @param {CMsgQAngle} message CMsgQAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgQAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };
    
        /**
         * Converts this CMsgQAngle to JSON.
         * @function toJSON
         * @memberof CMsgQAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgQAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgQAngle;
    })();
    
    $root.CMsgRGBA = (function() {
    
        /**
         * Properties of a CMsgRGBA.
         * @exports ICMsgRGBA
         * @interface ICMsgRGBA
         * @property {number|null} [r] CMsgRGBA r
         * @property {number|null} [g] CMsgRGBA g
         * @property {number|null} [b] CMsgRGBA b
         * @property {number|null} [a] CMsgRGBA a
         */
    
        /**
         * Constructs a new CMsgRGBA.
         * @exports CMsgRGBA
         * @classdesc Represents a CMsgRGBA.
         * @implements ICMsgRGBA
         * @constructor
         * @param {ICMsgRGBA=} [properties] Properties to set
         */
        function CMsgRGBA(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsgRGBA r.
         * @member {number} r
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.r = 0;
    
        /**
         * CMsgRGBA g.
         * @member {number} g
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.g = 0;
    
        /**
         * CMsgRGBA b.
         * @member {number} b
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.b = 0;
    
        /**
         * CMsgRGBA a.
         * @member {number} a
         * @memberof CMsgRGBA
         * @instance
         */
        CMsgRGBA.prototype.a = 0;
    
        /**
         * Creates a new CMsgRGBA instance using the specified properties.
         * @function create
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA=} [properties] Properties to set
         * @returns {CMsgRGBA} CMsgRGBA instance
         */
        CMsgRGBA.create = function create(properties) {
            return new CMsgRGBA(properties);
        };
    
        /**
         * Encodes the specified CMsgRGBA message. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encode
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.r != null && message.hasOwnProperty("r"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.r);
            if (message.g != null && message.hasOwnProperty("g"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.g);
            if (message.b != null && message.hasOwnProperty("b"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.b);
            if (message.a != null && message.hasOwnProperty("a"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.a);
            return writer;
        };
    
        /**
         * Encodes the specified CMsgRGBA message, length delimited. Does not implicitly {@link CMsgRGBA.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {ICMsgRGBA} message CMsgRGBA message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsgRGBA.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsgRGBA message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsgRGBA
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsgRGBA} CMsgRGBA
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsgRGBA.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsgRGBA message.
         * @function verify
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsgRGBA.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.r != null && message.hasOwnProperty("r"))
                if (!$util.isInteger(message.r))
                    return "r: integer expected";
            if (message.g != null && message.hasOwnProperty("g"))
                if (!$util.isInteger(message.g))
                    return "g: integer expected";
            if (message.b != null && message.hasOwnProperty("b"))
                if (!$util.isInteger(message.b))
                    return "b: integer expected";
            if (message.a != null && message.hasOwnProperty("a"))
                if (!$util.isInteger(message.a))
                    return "a: integer expected";
            return null;
        };
    
        /**
         * Creates a CMsgRGBA message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsgRGBA
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsgRGBA} CMsgRGBA
         */
        CMsgRGBA.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsgRGBA)
                return object;
            var message = new $root.CMsgRGBA();
            if (object.r != null)
                message.r = object.r | 0;
            if (object.g != null)
                message.g = object.g | 0;
            if (object.b != null)
                message.b = object.b | 0;
            if (object.a != null)
                message.a = object.a | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CMsgRGBA message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsgRGBA
         * @static
         * @param {CMsgRGBA} message CMsgRGBA
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsgRGBA.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.r = 0;
                object.g = 0;
                object.b = 0;
                object.a = 0;
            }
            if (message.r != null && message.hasOwnProperty("r"))
                object.r = message.r;
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = message.g;
            if (message.b != null && message.hasOwnProperty("b"))
                object.b = message.b;
            if (message.a != null && message.hasOwnProperty("a"))
                object.a = message.a;
            return object;
        };
    
        /**
         * Converts this CMsgRGBA to JSON.
         * @function toJSON
         * @memberof CMsgRGBA
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsgRGBA.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CMsgRGBA;
    })();
    
    $root.CNETMsg_Tick = (function() {
    
        /**
         * Properties of a CNETMsg_Tick.
         * @exports ICNETMsg_Tick
         * @interface ICNETMsg_Tick
         * @property {number|null} [tick] CNETMsg_Tick tick
         * @property {number|null} [host_computationtime] CNETMsg_Tick host_computationtime
         * @property {number|null} [host_computationtime_std_deviation] CNETMsg_Tick host_computationtime_std_deviation
         * @property {number|null} [host_framestarttime_std_deviation] CNETMsg_Tick host_framestarttime_std_deviation
         * @property {number|null} [hltv_replay_flags] CNETMsg_Tick hltv_replay_flags
         */
    
        /**
         * Constructs a new CNETMsg_Tick.
         * @exports CNETMsg_Tick
         * @classdesc Represents a CNETMsg_Tick.
         * @implements ICNETMsg_Tick
         * @constructor
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         */
        function CNETMsg_Tick(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Tick tick.
         * @member {number} tick
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.tick = 0;
    
        /**
         * CNETMsg_Tick host_computationtime.
         * @member {number} host_computationtime
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime = 0;
    
        /**
         * CNETMsg_Tick host_computationtime_std_deviation.
         * @member {number} host_computationtime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_computationtime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick host_framestarttime_std_deviation.
         * @member {number} host_framestarttime_std_deviation
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.host_framestarttime_std_deviation = 0;
    
        /**
         * CNETMsg_Tick hltv_replay_flags.
         * @member {number} hltv_replay_flags
         * @memberof CNETMsg_Tick
         * @instance
         */
        CNETMsg_Tick.prototype.hltv_replay_flags = 0;
    
        /**
         * Creates a new CNETMsg_Tick instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick=} [properties] Properties to set
         * @returns {CNETMsg_Tick} CNETMsg_Tick instance
         */
        CNETMsg_Tick.create = function create(properties) {
            return new CNETMsg_Tick(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tick != null && message.hasOwnProperty("tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.tick);
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.host_computationtime);
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.host_computationtime_std_deviation);
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.host_framestarttime_std_deviation);
            if (message.hltv_replay_flags != null && message.hasOwnProperty("hltv_replay_flags"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.hltv_replay_flags);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Tick message, length delimited. Does not implicitly {@link CNETMsg_Tick.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {ICNETMsg_Tick} message CNETMsg_Tick message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Tick.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 4:
                    message.host_computationtime = reader.uint32();
                    break;
                case 5:
                    message.host_computationtime_std_deviation = reader.uint32();
                    break;
                case 6:
                    message.host_framestarttime_std_deviation = reader.uint32();
                    break;
                case 7:
                    message.hltv_replay_flags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Tick message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Tick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Tick.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Tick message.
         * @function verify
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Tick.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tick != null && message.hasOwnProperty("tick"))
                if (!$util.isInteger(message.tick))
                    return "tick: integer expected";
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                if (!$util.isInteger(message.host_computationtime))
                    return "host_computationtime: integer expected";
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                if (!$util.isInteger(message.host_computationtime_std_deviation))
                    return "host_computationtime_std_deviation: integer expected";
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                if (!$util.isInteger(message.host_framestarttime_std_deviation))
                    return "host_framestarttime_std_deviation: integer expected";
            if (message.hltv_replay_flags != null && message.hasOwnProperty("hltv_replay_flags"))
                if (!$util.isInteger(message.hltv_replay_flags))
                    return "hltv_replay_flags: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Tick message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Tick} CNETMsg_Tick
         */
        CNETMsg_Tick.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Tick)
                return object;
            var message = new $root.CNETMsg_Tick();
            if (object.tick != null)
                message.tick = object.tick >>> 0;
            if (object.host_computationtime != null)
                message.host_computationtime = object.host_computationtime >>> 0;
            if (object.host_computationtime_std_deviation != null)
                message.host_computationtime_std_deviation = object.host_computationtime_std_deviation >>> 0;
            if (object.host_framestarttime_std_deviation != null)
                message.host_framestarttime_std_deviation = object.host_framestarttime_std_deviation >>> 0;
            if (object.hltv_replay_flags != null)
                message.hltv_replay_flags = object.hltv_replay_flags >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Tick message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Tick
         * @static
         * @param {CNETMsg_Tick} message CNETMsg_Tick
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Tick.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tick = 0;
                object.host_computationtime = 0;
                object.host_computationtime_std_deviation = 0;
                object.host_framestarttime_std_deviation = 0;
                object.hltv_replay_flags = 0;
            }
            if (message.tick != null && message.hasOwnProperty("tick"))
                object.tick = message.tick;
            if (message.host_computationtime != null && message.hasOwnProperty("host_computationtime"))
                object.host_computationtime = message.host_computationtime;
            if (message.host_computationtime_std_deviation != null && message.hasOwnProperty("host_computationtime_std_deviation"))
                object.host_computationtime_std_deviation = message.host_computationtime_std_deviation;
            if (message.host_framestarttime_std_deviation != null && message.hasOwnProperty("host_framestarttime_std_deviation"))
                object.host_framestarttime_std_deviation = message.host_framestarttime_std_deviation;
            if (message.hltv_replay_flags != null && message.hasOwnProperty("hltv_replay_flags"))
                object.hltv_replay_flags = message.hltv_replay_flags;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Tick to JSON.
         * @function toJSON
         * @memberof CNETMsg_Tick
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Tick.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Tick;
    })();
    
    $root.CNETMsg_StringCmd = (function() {
    
        /**
         * Properties of a CNETMsg_StringCmd.
         * @exports ICNETMsg_StringCmd
         * @interface ICNETMsg_StringCmd
         * @property {string|null} [command] CNETMsg_StringCmd command
         */
    
        /**
         * Constructs a new CNETMsg_StringCmd.
         * @exports CNETMsg_StringCmd
         * @classdesc Represents a CNETMsg_StringCmd.
         * @implements ICNETMsg_StringCmd
         * @constructor
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         */
        function CNETMsg_StringCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_StringCmd command.
         * @member {string} command
         * @memberof CNETMsg_StringCmd
         * @instance
         */
        CNETMsg_StringCmd.prototype.command = "";
    
        /**
         * Creates a new CNETMsg_StringCmd instance using the specified properties.
         * @function create
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd=} [properties] Properties to set
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd instance
         */
        CNETMsg_StringCmd.create = function create(properties) {
            return new CNETMsg_StringCmd(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && message.hasOwnProperty("command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_StringCmd message, length delimited. Does not implicitly {@link CNETMsg_StringCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {ICNETMsg_StringCmd} message CNETMsg_StringCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_StringCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_StringCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_StringCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_StringCmd message.
         * @function verify
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_StringCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_StringCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
         */
        CNETMsg_StringCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_StringCmd)
                return object;
            var message = new $root.CNETMsg_StringCmd();
            if (object.command != null)
                message.command = String(object.command);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_StringCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_StringCmd
         * @static
         * @param {CNETMsg_StringCmd} message CNETMsg_StringCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_StringCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.command = "";
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            return object;
        };
    
        /**
         * Converts this CNETMsg_StringCmd to JSON.
         * @function toJSON
         * @memberof CNETMsg_StringCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_StringCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_StringCmd;
    })();
    
    $root.CNETMsg_SignonState = (function() {
    
        /**
         * Properties of a CNETMsg_SignonState.
         * @exports ICNETMsg_SignonState
         * @interface ICNETMsg_SignonState
         * @property {number|null} [signon_state] CNETMsg_SignonState signon_state
         * @property {number|null} [spawn_count] CNETMsg_SignonState spawn_count
         * @property {number|null} [num_server_players] CNETMsg_SignonState num_server_players
         * @property {Array.<string>|null} [players_networkids] CNETMsg_SignonState players_networkids
         * @property {string|null} [map_name] CNETMsg_SignonState map_name
         */
    
        /**
         * Constructs a new CNETMsg_SignonState.
         * @exports CNETMsg_SignonState
         * @classdesc Represents a CNETMsg_SignonState.
         * @implements ICNETMsg_SignonState
         * @constructor
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         */
        function CNETMsg_SignonState(properties) {
            this.players_networkids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SignonState signon_state.
         * @member {number} signon_state
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.signon_state = 0;
    
        /**
         * CNETMsg_SignonState spawn_count.
         * @member {number} spawn_count
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.spawn_count = 0;
    
        /**
         * CNETMsg_SignonState num_server_players.
         * @member {number} num_server_players
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.num_server_players = 0;
    
        /**
         * CNETMsg_SignonState players_networkids.
         * @member {Array.<string>} players_networkids
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.players_networkids = $util.emptyArray;
    
        /**
         * CNETMsg_SignonState map_name.
         * @member {string} map_name
         * @memberof CNETMsg_SignonState
         * @instance
         */
        CNETMsg_SignonState.prototype.map_name = "";
    
        /**
         * Creates a new CNETMsg_SignonState instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState=} [properties] Properties to set
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState instance
         */
        CNETMsg_SignonState.create = function create(properties) {
            return new CNETMsg_SignonState(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.signon_state);
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spawn_count);
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_server_players);
            if (message.players_networkids != null && message.players_networkids.length)
                for (var i = 0; i < message.players_networkids.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.players_networkids[i]);
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.map_name);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SignonState message, length delimited. Does not implicitly {@link CNETMsg_SignonState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {ICNETMsg_SignonState} message CNETMsg_SignonState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SignonState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signon_state = reader.uint32();
                    break;
                case 2:
                    message.spawn_count = reader.uint32();
                    break;
                case 3:
                    message.num_server_players = reader.uint32();
                    break;
                case 4:
                    if (!(message.players_networkids && message.players_networkids.length))
                        message.players_networkids = [];
                    message.players_networkids.push(reader.string());
                    break;
                case 5:
                    message.map_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SignonState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SignonState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SignonState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SignonState message.
         * @function verify
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SignonState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                if (!$util.isInteger(message.signon_state))
                    return "signon_state: integer expected";
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                if (!$util.isInteger(message.spawn_count))
                    return "spawn_count: integer expected";
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                if (!$util.isInteger(message.num_server_players))
                    return "num_server_players: integer expected";
            if (message.players_networkids != null && message.hasOwnProperty("players_networkids")) {
                if (!Array.isArray(message.players_networkids))
                    return "players_networkids: array expected";
                for (var i = 0; i < message.players_networkids.length; ++i)
                    if (!$util.isString(message.players_networkids[i]))
                        return "players_networkids: string[] expected";
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SignonState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SignonState} CNETMsg_SignonState
         */
        CNETMsg_SignonState.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SignonState)
                return object;
            var message = new $root.CNETMsg_SignonState();
            if (object.signon_state != null)
                message.signon_state = object.signon_state >>> 0;
            if (object.spawn_count != null)
                message.spawn_count = object.spawn_count >>> 0;
            if (object.num_server_players != null)
                message.num_server_players = object.num_server_players >>> 0;
            if (object.players_networkids) {
                if (!Array.isArray(object.players_networkids))
                    throw TypeError(".CNETMsg_SignonState.players_networkids: array expected");
                message.players_networkids = [];
                for (var i = 0; i < object.players_networkids.length; ++i)
                    message.players_networkids[i] = String(object.players_networkids[i]);
            }
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SignonState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SignonState
         * @static
         * @param {CNETMsg_SignonState} message CNETMsg_SignonState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SignonState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.players_networkids = [];
            if (options.defaults) {
                object.signon_state = 0;
                object.spawn_count = 0;
                object.num_server_players = 0;
                object.map_name = "";
            }
            if (message.signon_state != null && message.hasOwnProperty("signon_state"))
                object.signon_state = message.signon_state;
            if (message.spawn_count != null && message.hasOwnProperty("spawn_count"))
                object.spawn_count = message.spawn_count;
            if (message.num_server_players != null && message.hasOwnProperty("num_server_players"))
                object.num_server_players = message.num_server_players;
            if (message.players_networkids && message.players_networkids.length) {
                object.players_networkids = [];
                for (var j = 0; j < message.players_networkids.length; ++j)
                    object.players_networkids[j] = message.players_networkids[j];
            }
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SignonState to JSON.
         * @function toJSON
         * @memberof CNETMsg_SignonState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SignonState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SignonState;
    })();
    
    $root.CMsg_CVars = (function() {
    
        /**
         * Properties of a CMsg_CVars.
         * @exports ICMsg_CVars
         * @interface ICMsg_CVars
         * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
         */
    
        /**
         * Constructs a new CMsg_CVars.
         * @exports CMsg_CVars
         * @classdesc Represents a CMsg_CVars.
         * @implements ICMsg_CVars
         * @constructor
         * @param {ICMsg_CVars=} [properties] Properties to set
         */
        function CMsg_CVars(properties) {
            this.cvars = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CMsg_CVars cvars.
         * @member {Array.<CMsg_CVars.ICVar>} cvars
         * @memberof CMsg_CVars
         * @instance
         */
        CMsg_CVars.prototype.cvars = $util.emptyArray;
    
        /**
         * Creates a new CMsg_CVars instance using the specified properties.
         * @function create
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars=} [properties] Properties to set
         * @returns {CMsg_CVars} CMsg_CVars instance
         */
        CMsg_CVars.create = function create(properties) {
            return new CMsg_CVars(properties);
        };
    
        /**
         * Encodes the specified CMsg_CVars message. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encode
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cvars != null && message.cvars.length)
                for (var i = 0; i < message.cvars.length; ++i)
                    $root.CMsg_CVars.CVar.encode(message.cvars[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CMsg_CVars message, length delimited. Does not implicitly {@link CMsg_CVars.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {ICMsg_CVars} message CMsg_CVars message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CMsg_CVars.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CMsg_CVars message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CMsg_CVars
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CMsg_CVars} CMsg_CVars
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CMsg_CVars.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CMsg_CVars message.
         * @function verify
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CMsg_CVars.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cvars != null && message.hasOwnProperty("cvars")) {
                if (!Array.isArray(message.cvars))
                    return "cvars: array expected";
                for (var i = 0; i < message.cvars.length; ++i) {
                    var error = $root.CMsg_CVars.CVar.verify(message.cvars[i]);
                    if (error)
                        return "cvars." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CMsg_CVars message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CMsg_CVars
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CMsg_CVars} CMsg_CVars
         */
        CMsg_CVars.fromObject = function fromObject(object) {
            if (object instanceof $root.CMsg_CVars)
                return object;
            var message = new $root.CMsg_CVars();
            if (object.cvars) {
                if (!Array.isArray(object.cvars))
                    throw TypeError(".CMsg_CVars.cvars: array expected");
                message.cvars = [];
                for (var i = 0; i < object.cvars.length; ++i) {
                    if (typeof object.cvars[i] !== "object")
                        throw TypeError(".CMsg_CVars.cvars: object expected");
                    message.cvars[i] = $root.CMsg_CVars.CVar.fromObject(object.cvars[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CMsg_CVars message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CMsg_CVars
         * @static
         * @param {CMsg_CVars} message CMsg_CVars
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CMsg_CVars.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cvars = [];
            if (message.cvars && message.cvars.length) {
                object.cvars = [];
                for (var j = 0; j < message.cvars.length; ++j)
                    object.cvars[j] = $root.CMsg_CVars.CVar.toObject(message.cvars[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CMsg_CVars to JSON.
         * @function toJSON
         * @memberof CMsg_CVars
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CMsg_CVars.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CMsg_CVars.CVar = (function() {
    
            /**
             * Properties of a CVar.
             * @memberof CMsg_CVars
             * @interface ICVar
             * @property {string|null} [name] CVar name
             * @property {string|null} [value] CVar value
             * @property {number|null} [dictionary_name] CVar dictionary_name
             */
    
            /**
             * Constructs a new CVar.
             * @memberof CMsg_CVars
             * @classdesc Represents a CVar.
             * @implements ICVar
             * @constructor
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             */
            function CVar(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CVar name.
             * @member {string} name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.name = "";
    
            /**
             * CVar value.
             * @member {string} value
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.value = "";
    
            /**
             * CVar dictionary_name.
             * @member {number} dictionary_name
             * @memberof CMsg_CVars.CVar
             * @instance
             */
            CVar.prototype.dictionary_name = 0;
    
            /**
             * Creates a new CVar instance using the specified properties.
             * @function create
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar=} [properties] Properties to set
             * @returns {CMsg_CVars.CVar} CVar instance
             */
            CVar.create = function create(properties) {
                return new CVar(properties);
            };
    
            /**
             * Encodes the specified CVar message. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                if (message.dictionary_name != null && message.hasOwnProperty("dictionary_name"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dictionary_name);
                return writer;
            };
    
            /**
             * Encodes the specified CVar message, length delimited. Does not implicitly {@link CMsg_CVars.CVar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.ICVar} message CVar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CVar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer.
             * @function decode
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.dictionary_name = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CVar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CMsg_CVars.CVar} CVar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CVar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CVar message.
             * @function verify
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CVar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                if (message.dictionary_name != null && message.hasOwnProperty("dictionary_name"))
                    if (!$util.isInteger(message.dictionary_name))
                        return "dictionary_name: integer expected";
                return null;
            };
    
            /**
             * Creates a CVar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CMsg_CVars.CVar} CVar
             */
            CVar.fromObject = function fromObject(object) {
                if (object instanceof $root.CMsg_CVars.CVar)
                    return object;
                var message = new $root.CMsg_CVars.CVar();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    message.value = String(object.value);
                if (object.dictionary_name != null)
                    message.dictionary_name = object.dictionary_name >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a CVar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CMsg_CVars.CVar
             * @static
             * @param {CMsg_CVars.CVar} message CVar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CVar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.value = "";
                    object.dictionary_name = 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.dictionary_name != null && message.hasOwnProperty("dictionary_name"))
                    object.dictionary_name = message.dictionary_name;
                return object;
            };
    
            /**
             * Converts this CVar to JSON.
             * @function toJSON
             * @memberof CMsg_CVars.CVar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CVar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CVar;
        })();
    
        return CMsg_CVars;
    })();
    
    $root.CNETMsg_SetConVar = (function() {
    
        /**
         * Properties of a CNETMsg_SetConVar.
         * @exports ICNETMsg_SetConVar
         * @interface ICNETMsg_SetConVar
         * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
         */
    
        /**
         * Constructs a new CNETMsg_SetConVar.
         * @exports CNETMsg_SetConVar
         * @classdesc Represents a CNETMsg_SetConVar.
         * @implements ICNETMsg_SetConVar
         * @constructor
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         */
        function CNETMsg_SetConVar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SetConVar convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CNETMsg_SetConVar
         * @instance
         */
        CNETMsg_SetConVar.prototype.convars = null;
    
        /**
         * Creates a new CNETMsg_SetConVar instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar=} [properties] Properties to set
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar instance
         */
        CNETMsg_SetConVar.create = function create(properties) {
            return new CNETMsg_SetConVar(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && message.hasOwnProperty("convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SetConVar message, length delimited. Does not implicitly {@link CNETMsg_SetConVar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {ICNETMsg_SetConVar} message CNETMsg_SetConVar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SetConVar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SetConVar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SetConVar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SetConVar message.
         * @function verify
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SetConVar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CNETMsg_SetConVar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
         */
        CNETMsg_SetConVar.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SetConVar)
                return object;
            var message = new $root.CNETMsg_SetConVar();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CNETMsg_SetConVar.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SetConVar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SetConVar
         * @static
         * @param {CNETMsg_SetConVar} message CNETMsg_SetConVar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SetConVar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CNETMsg_SetConVar to JSON.
         * @function toJSON
         * @memberof CNETMsg_SetConVar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SetConVar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SetConVar;
    })();
    
    $root.CNETMsg_NOP = (function() {
    
        /**
         * Properties of a CNETMsg_NOP.
         * @exports ICNETMsg_NOP
         * @interface ICNETMsg_NOP
         */
    
        /**
         * Constructs a new CNETMsg_NOP.
         * @exports CNETMsg_NOP
         * @classdesc Represents a CNETMsg_NOP.
         * @implements ICNETMsg_NOP
         * @constructor
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         */
        function CNETMsg_NOP(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CNETMsg_NOP instance using the specified properties.
         * @function create
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP=} [properties] Properties to set
         * @returns {CNETMsg_NOP} CNETMsg_NOP instance
         */
        CNETMsg_NOP.create = function create(properties) {
            return new CNETMsg_NOP(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_NOP message, length delimited. Does not implicitly {@link CNETMsg_NOP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {ICNETMsg_NOP} message CNETMsg_NOP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_NOP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_NOP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_NOP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_NOP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_NOP message.
         * @function verify
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_NOP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_NOP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_NOP} CNETMsg_NOP
         */
        CNETMsg_NOP.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_NOP)
                return object;
            return new $root.CNETMsg_NOP();
        };
    
        /**
         * Creates a plain object from a CNETMsg_NOP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_NOP
         * @static
         * @param {CNETMsg_NOP} message CNETMsg_NOP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_NOP.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CNETMsg_NOP to JSON.
         * @function toJSON
         * @memberof CNETMsg_NOP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_NOP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_NOP;
    })();
    
    $root.CNETMsg_Disconnect = (function() {
    
        /**
         * Properties of a CNETMsg_Disconnect.
         * @exports ICNETMsg_Disconnect
         * @interface ICNETMsg_Disconnect
         * @property {string|null} [text] CNETMsg_Disconnect text
         */
    
        /**
         * Constructs a new CNETMsg_Disconnect.
         * @exports CNETMsg_Disconnect
         * @classdesc Represents a CNETMsg_Disconnect.
         * @implements ICNETMsg_Disconnect
         * @constructor
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         */
        function CNETMsg_Disconnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_Disconnect text.
         * @member {string} text
         * @memberof CNETMsg_Disconnect
         * @instance
         */
        CNETMsg_Disconnect.prototype.text = "";
    
        /**
         * Creates a new CNETMsg_Disconnect instance using the specified properties.
         * @function create
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect=} [properties] Properties to set
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect instance
         */
        CNETMsg_Disconnect.create = function create(properties) {
            return new CNETMsg_Disconnect(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_Disconnect message, length delimited. Does not implicitly {@link CNETMsg_Disconnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {ICNETMsg_Disconnect} message CNETMsg_Disconnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_Disconnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_Disconnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_Disconnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_Disconnect message.
         * @function verify
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_Disconnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_Disconnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
         */
        CNETMsg_Disconnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_Disconnect)
                return object;
            var message = new $root.CNETMsg_Disconnect();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_Disconnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_Disconnect
         * @static
         * @param {CNETMsg_Disconnect} message CNETMsg_Disconnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_Disconnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CNETMsg_Disconnect to JSON.
         * @function toJSON
         * @memberof CNETMsg_Disconnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_Disconnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_Disconnect;
    })();
    
    $root.CNETMsg_File = (function() {
    
        /**
         * Properties of a CNETMsg_File.
         * @exports ICNETMsg_File
         * @interface ICNETMsg_File
         * @property {number|null} [transfer_id] CNETMsg_File transfer_id
         * @property {string|null} [file_name] CNETMsg_File file_name
         * @property {boolean|null} [is_replay_demo_file] CNETMsg_File is_replay_demo_file
         * @property {boolean|null} [deny] CNETMsg_File deny
         */
    
        /**
         * Constructs a new CNETMsg_File.
         * @exports CNETMsg_File
         * @classdesc Represents a CNETMsg_File.
         * @implements ICNETMsg_File
         * @constructor
         * @param {ICNETMsg_File=} [properties] Properties to set
         */
        function CNETMsg_File(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_File transfer_id.
         * @member {number} transfer_id
         * @memberof CNETMsg_File
         * @instance
         */
        CNETMsg_File.prototype.transfer_id = 0;
    
        /**
         * CNETMsg_File file_name.
         * @member {string} file_name
         * @memberof CNETMsg_File
         * @instance
         */
        CNETMsg_File.prototype.file_name = "";
    
        /**
         * CNETMsg_File is_replay_demo_file.
         * @member {boolean} is_replay_demo_file
         * @memberof CNETMsg_File
         * @instance
         */
        CNETMsg_File.prototype.is_replay_demo_file = false;
    
        /**
         * CNETMsg_File deny.
         * @member {boolean} deny
         * @memberof CNETMsg_File
         * @instance
         */
        CNETMsg_File.prototype.deny = false;
    
        /**
         * Creates a new CNETMsg_File instance using the specified properties.
         * @function create
         * @memberof CNETMsg_File
         * @static
         * @param {ICNETMsg_File=} [properties] Properties to set
         * @returns {CNETMsg_File} CNETMsg_File instance
         */
        CNETMsg_File.create = function create(properties) {
            return new CNETMsg_File(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_File message. Does not implicitly {@link CNETMsg_File.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_File
         * @static
         * @param {ICNETMsg_File} message CNETMsg_File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_File.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transfer_id != null && message.hasOwnProperty("transfer_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.transfer_id);
            if (message.file_name != null && message.hasOwnProperty("file_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.file_name);
            if (message.is_replay_demo_file != null && message.hasOwnProperty("is_replay_demo_file"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_replay_demo_file);
            if (message.deny != null && message.hasOwnProperty("deny"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.deny);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_File message, length delimited. Does not implicitly {@link CNETMsg_File.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_File
         * @static
         * @param {ICNETMsg_File} message CNETMsg_File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_File.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_File message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_File} CNETMsg_File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_File.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_File();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transfer_id = reader.int32();
                    break;
                case 2:
                    message.file_name = reader.string();
                    break;
                case 3:
                    message.is_replay_demo_file = reader.bool();
                    break;
                case 4:
                    message.deny = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_File message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_File} CNETMsg_File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_File.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_File message.
         * @function verify
         * @memberof CNETMsg_File
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_File.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transfer_id != null && message.hasOwnProperty("transfer_id"))
                if (!$util.isInteger(message.transfer_id))
                    return "transfer_id: integer expected";
            if (message.file_name != null && message.hasOwnProperty("file_name"))
                if (!$util.isString(message.file_name))
                    return "file_name: string expected";
            if (message.is_replay_demo_file != null && message.hasOwnProperty("is_replay_demo_file"))
                if (typeof message.is_replay_demo_file !== "boolean")
                    return "is_replay_demo_file: boolean expected";
            if (message.deny != null && message.hasOwnProperty("deny"))
                if (typeof message.deny !== "boolean")
                    return "deny: boolean expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_File message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_File
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_File} CNETMsg_File
         */
        CNETMsg_File.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_File)
                return object;
            var message = new $root.CNETMsg_File();
            if (object.transfer_id != null)
                message.transfer_id = object.transfer_id | 0;
            if (object.file_name != null)
                message.file_name = String(object.file_name);
            if (object.is_replay_demo_file != null)
                message.is_replay_demo_file = Boolean(object.is_replay_demo_file);
            if (object.deny != null)
                message.deny = Boolean(object.deny);
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_File message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_File
         * @static
         * @param {CNETMsg_File} message CNETMsg_File
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_File.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transfer_id = 0;
                object.file_name = "";
                object.is_replay_demo_file = false;
                object.deny = false;
            }
            if (message.transfer_id != null && message.hasOwnProperty("transfer_id"))
                object.transfer_id = message.transfer_id;
            if (message.file_name != null && message.hasOwnProperty("file_name"))
                object.file_name = message.file_name;
            if (message.is_replay_demo_file != null && message.hasOwnProperty("is_replay_demo_file"))
                object.is_replay_demo_file = message.is_replay_demo_file;
            if (message.deny != null && message.hasOwnProperty("deny"))
                object.deny = message.deny;
            return object;
        };
    
        /**
         * Converts this CNETMsg_File to JSON.
         * @function toJSON
         * @memberof CNETMsg_File
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_File.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_File;
    })();
    
    $root.CNETMsg_SplitScreenUser = (function() {
    
        /**
         * Properties of a CNETMsg_SplitScreenUser.
         * @exports ICNETMsg_SplitScreenUser
         * @interface ICNETMsg_SplitScreenUser
         * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
         */
    
        /**
         * Constructs a new CNETMsg_SplitScreenUser.
         * @exports CNETMsg_SplitScreenUser
         * @classdesc Represents a CNETMsg_SplitScreenUser.
         * @implements ICNETMsg_SplitScreenUser
         * @constructor
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         */
        function CNETMsg_SplitScreenUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_SplitScreenUser slot.
         * @member {number} slot
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         */
        CNETMsg_SplitScreenUser.prototype.slot = 0;
    
        /**
         * Creates a new CNETMsg_SplitScreenUser instance using the specified properties.
         * @function create
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser instance
         */
        CNETMsg_SplitScreenUser.create = function create(properties) {
            return new CNETMsg_SplitScreenUser(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.slot != null && message.hasOwnProperty("slot"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.slot);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_SplitScreenUser message, length delimited. Does not implicitly {@link CNETMsg_SplitScreenUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {ICNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_SplitScreenUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_SplitScreenUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_SplitScreenUser message.
         * @function verify
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_SplitScreenUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_SplitScreenUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
         */
        CNETMsg_SplitScreenUser.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_SplitScreenUser)
                return object;
            var message = new $root.CNETMsg_SplitScreenUser();
            if (object.slot != null)
                message.slot = object.slot | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_SplitScreenUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_SplitScreenUser
         * @static
         * @param {CNETMsg_SplitScreenUser} message CNETMsg_SplitScreenUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_SplitScreenUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.slot = 0;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            return object;
        };
    
        /**
         * Converts this CNETMsg_SplitScreenUser to JSON.
         * @function toJSON
         * @memberof CNETMsg_SplitScreenUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_SplitScreenUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_SplitScreenUser;
    })();
    
    $root.CNETMsg_PlayerAvatarData = (function() {
    
        /**
         * Properties of a CNETMsg_PlayerAvatarData.
         * @exports ICNETMsg_PlayerAvatarData
         * @interface ICNETMsg_PlayerAvatarData
         * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid
         * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb
         */
    
        /**
         * Constructs a new CNETMsg_PlayerAvatarData.
         * @exports CNETMsg_PlayerAvatarData
         * @classdesc Represents a CNETMsg_PlayerAvatarData.
         * @implements ICNETMsg_PlayerAvatarData
         * @constructor
         * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set
         */
        function CNETMsg_PlayerAvatarData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CNETMsg_PlayerAvatarData accountid.
         * @member {number} accountid
         * @memberof CNETMsg_PlayerAvatarData
         * @instance
         */
        CNETMsg_PlayerAvatarData.prototype.accountid = 0;
    
        /**
         * CNETMsg_PlayerAvatarData rgb.
         * @member {Uint8Array} rgb
         * @memberof CNETMsg_PlayerAvatarData
         * @instance
         */
        CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);
    
        /**
         * Creates a new CNETMsg_PlayerAvatarData instance using the specified properties.
         * @function create
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set
         * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData instance
         */
        CNETMsg_PlayerAvatarData.create = function create(properties) {
            return new CNETMsg_PlayerAvatarData(properties);
        };
    
        /**
         * Encodes the specified CNETMsg_PlayerAvatarData message. Does not implicitly {@link CNETMsg_PlayerAvatarData.verify|verify} messages.
         * @function encode
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {ICNETMsg_PlayerAvatarData} message CNETMsg_PlayerAvatarData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_PlayerAvatarData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountid != null && message.hasOwnProperty("accountid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.accountid);
            if (message.rgb != null && message.hasOwnProperty("rgb"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rgb);
            return writer;
        };
    
        /**
         * Encodes the specified CNETMsg_PlayerAvatarData message, length delimited. Does not implicitly {@link CNETMsg_PlayerAvatarData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {ICNETMsg_PlayerAvatarData} message CNETMsg_PlayerAvatarData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CNETMsg_PlayerAvatarData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.
         * @function decode
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_PlayerAvatarData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.rgb = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CNETMsg_PlayerAvatarData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CNETMsg_PlayerAvatarData message.
         * @function verify
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CNETMsg_PlayerAvatarData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountid != null && message.hasOwnProperty("accountid"))
                if (!$util.isInteger(message.accountid))
                    return "accountid: integer expected";
            if (message.rgb != null && message.hasOwnProperty("rgb"))
                if (!(message.rgb && typeof message.rgb.length === "number" || $util.isString(message.rgb)))
                    return "rgb: buffer expected";
            return null;
        };
    
        /**
         * Creates a CNETMsg_PlayerAvatarData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
         */
        CNETMsg_PlayerAvatarData.fromObject = function fromObject(object) {
            if (object instanceof $root.CNETMsg_PlayerAvatarData)
                return object;
            var message = new $root.CNETMsg_PlayerAvatarData();
            if (object.accountid != null)
                message.accountid = object.accountid >>> 0;
            if (object.rgb != null)
                if (typeof object.rgb === "string")
                    $util.base64.decode(object.rgb, message.rgb = $util.newBuffer($util.base64.length(object.rgb)), 0);
                else if (object.rgb.length)
                    message.rgb = object.rgb;
            return message;
        };
    
        /**
         * Creates a plain object from a CNETMsg_PlayerAvatarData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CNETMsg_PlayerAvatarData
         * @static
         * @param {CNETMsg_PlayerAvatarData} message CNETMsg_PlayerAvatarData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CNETMsg_PlayerAvatarData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.accountid = 0;
                if (options.bytes === String)
                    object.rgb = "";
                else {
                    object.rgb = [];
                    if (options.bytes !== Array)
                        object.rgb = $util.newBuffer(object.rgb);
                }
            }
            if (message.accountid != null && message.hasOwnProperty("accountid"))
                object.accountid = message.accountid;
            if (message.rgb != null && message.hasOwnProperty("rgb"))
                object.rgb = options.bytes === String ? $util.base64.encode(message.rgb, 0, message.rgb.length) : options.bytes === Array ? Array.prototype.slice.call(message.rgb) : message.rgb;
            return object;
        };
    
        /**
         * Converts this CNETMsg_PlayerAvatarData to JSON.
         * @function toJSON
         * @memberof CNETMsg_PlayerAvatarData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CNETMsg_PlayerAvatarData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CNETMsg_PlayerAvatarData;
    })();
    
    $root.CCLCMsg_ClientInfo = (function() {
    
        /**
         * Properties of a CCLCMsg_ClientInfo.
         * @exports ICCLCMsg_ClientInfo
         * @interface ICCLCMsg_ClientInfo
         * @property {number|null} [send_table_crc] CCLCMsg_ClientInfo send_table_crc
         * @property {number|null} [server_count] CCLCMsg_ClientInfo server_count
         * @property {boolean|null} [is_hltv] CCLCMsg_ClientInfo is_hltv
         * @property {boolean|null} [is_replay] CCLCMsg_ClientInfo is_replay
         * @property {number|null} [friends_id] CCLCMsg_ClientInfo friends_id
         * @property {string|null} [friends_name] CCLCMsg_ClientInfo friends_name
         * @property {Array.<number>|null} [custom_files] CCLCMsg_ClientInfo custom_files
         */
    
        /**
         * Constructs a new CCLCMsg_ClientInfo.
         * @exports CCLCMsg_ClientInfo
         * @classdesc Represents a CCLCMsg_ClientInfo.
         * @implements ICCLCMsg_ClientInfo
         * @constructor
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         */
        function CCLCMsg_ClientInfo(properties) {
            this.custom_files = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ClientInfo send_table_crc.
         * @member {number} send_table_crc
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.send_table_crc = 0;
    
        /**
         * CCLCMsg_ClientInfo server_count.
         * @member {number} server_count
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.server_count = 0;
    
        /**
         * CCLCMsg_ClientInfo is_hltv.
         * @member {boolean} is_hltv
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.is_hltv = false;
    
        /**
         * CCLCMsg_ClientInfo is_replay.
         * @member {boolean} is_replay
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.is_replay = false;
    
        /**
         * CCLCMsg_ClientInfo friends_id.
         * @member {number} friends_id
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friends_id = 0;
    
        /**
         * CCLCMsg_ClientInfo friends_name.
         * @member {string} friends_name
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.friends_name = "";
    
        /**
         * CCLCMsg_ClientInfo custom_files.
         * @member {Array.<number>} custom_files
         * @memberof CCLCMsg_ClientInfo
         * @instance
         */
        CCLCMsg_ClientInfo.prototype.custom_files = $util.emptyArray;
    
        /**
         * Creates a new CCLCMsg_ClientInfo instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo instance
         */
        CCLCMsg_ClientInfo.create = function create(properties) {
            return new CCLCMsg_ClientInfo(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.send_table_crc != null && message.hasOwnProperty("send_table_crc"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.send_table_crc);
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.server_count);
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_hltv);
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_replay);
            if (message.friends_id != null && message.hasOwnProperty("friends_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.friends_id);
            if (message.friends_name != null && message.hasOwnProperty("friends_name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.friends_name);
            if (message.custom_files != null && message.custom_files.length)
                for (var i = 0; i < message.custom_files.length; ++i)
                    writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.custom_files[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ClientInfo message, length delimited. Does not implicitly {@link CCLCMsg_ClientInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {ICCLCMsg_ClientInfo} message CCLCMsg_ClientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.send_table_crc = reader.fixed32();
                    break;
                case 2:
                    message.server_count = reader.uint32();
                    break;
                case 3:
                    message.is_hltv = reader.bool();
                    break;
                case 4:
                    message.is_replay = reader.bool();
                    break;
                case 5:
                    message.friends_id = reader.uint32();
                    break;
                case 6:
                    message.friends_name = reader.string();
                    break;
                case 7:
                    if (!(message.custom_files && message.custom_files.length))
                        message.custom_files = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.custom_files.push(reader.fixed32());
                    } else
                        message.custom_files.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ClientInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ClientInfo message.
         * @function verify
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ClientInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.send_table_crc != null && message.hasOwnProperty("send_table_crc"))
                if (!$util.isInteger(message.send_table_crc))
                    return "send_table_crc: integer expected";
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                if (!$util.isInteger(message.server_count))
                    return "server_count: integer expected";
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                if (typeof message.is_hltv !== "boolean")
                    return "is_hltv: boolean expected";
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                if (typeof message.is_replay !== "boolean")
                    return "is_replay: boolean expected";
            if (message.friends_id != null && message.hasOwnProperty("friends_id"))
                if (!$util.isInteger(message.friends_id))
                    return "friends_id: integer expected";
            if (message.friends_name != null && message.hasOwnProperty("friends_name"))
                if (!$util.isString(message.friends_name))
                    return "friends_name: string expected";
            if (message.custom_files != null && message.hasOwnProperty("custom_files")) {
                if (!Array.isArray(message.custom_files))
                    return "custom_files: array expected";
                for (var i = 0; i < message.custom_files.length; ++i)
                    if (!$util.isInteger(message.custom_files[i]))
                        return "custom_files: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ClientInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
         */
        CCLCMsg_ClientInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ClientInfo)
                return object;
            var message = new $root.CCLCMsg_ClientInfo();
            if (object.send_table_crc != null)
                message.send_table_crc = object.send_table_crc >>> 0;
            if (object.server_count != null)
                message.server_count = object.server_count >>> 0;
            if (object.is_hltv != null)
                message.is_hltv = Boolean(object.is_hltv);
            if (object.is_replay != null)
                message.is_replay = Boolean(object.is_replay);
            if (object.friends_id != null)
                message.friends_id = object.friends_id >>> 0;
            if (object.friends_name != null)
                message.friends_name = String(object.friends_name);
            if (object.custom_files) {
                if (!Array.isArray(object.custom_files))
                    throw TypeError(".CCLCMsg_ClientInfo.custom_files: array expected");
                message.custom_files = [];
                for (var i = 0; i < object.custom_files.length; ++i)
                    message.custom_files[i] = object.custom_files[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ClientInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ClientInfo
         * @static
         * @param {CCLCMsg_ClientInfo} message CCLCMsg_ClientInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ClientInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.custom_files = [];
            if (options.defaults) {
                object.send_table_crc = 0;
                object.server_count = 0;
                object.is_hltv = false;
                object.is_replay = false;
                object.friends_id = 0;
                object.friends_name = "";
            }
            if (message.send_table_crc != null && message.hasOwnProperty("send_table_crc"))
                object.send_table_crc = message.send_table_crc;
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                object.server_count = message.server_count;
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                object.is_hltv = message.is_hltv;
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                object.is_replay = message.is_replay;
            if (message.friends_id != null && message.hasOwnProperty("friends_id"))
                object.friends_id = message.friends_id;
            if (message.friends_name != null && message.hasOwnProperty("friends_name"))
                object.friends_name = message.friends_name;
            if (message.custom_files && message.custom_files.length) {
                object.custom_files = [];
                for (var j = 0; j < message.custom_files.length; ++j)
                    object.custom_files[j] = message.custom_files[j];
            }
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ClientInfo to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ClientInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ClientInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ClientInfo;
    })();
    
    $root.CCLCMsg_Move = (function() {
    
        /**
         * Properties of a CCLCMsg_Move.
         * @exports ICCLCMsg_Move
         * @interface ICCLCMsg_Move
         * @property {number|null} [num_backup_commands] CCLCMsg_Move num_backup_commands
         * @property {number|null} [num_new_commands] CCLCMsg_Move num_new_commands
         * @property {Uint8Array|null} [data] CCLCMsg_Move data
         */
    
        /**
         * Constructs a new CCLCMsg_Move.
         * @exports CCLCMsg_Move
         * @classdesc Represents a CCLCMsg_Move.
         * @implements ICCLCMsg_Move
         * @constructor
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         */
        function CCLCMsg_Move(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_Move num_backup_commands.
         * @member {number} num_backup_commands
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.num_backup_commands = 0;
    
        /**
         * CCLCMsg_Move num_new_commands.
         * @member {number} num_new_commands
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.num_new_commands = 0;
    
        /**
         * CCLCMsg_Move data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_Move
         * @instance
         */
        CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_Move instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move=} [properties] Properties to set
         * @returns {CCLCMsg_Move} CCLCMsg_Move instance
         */
        CCLCMsg_Move.create = function create(properties) {
            return new CCLCMsg_Move(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.num_backup_commands != null && message.hasOwnProperty("num_backup_commands"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.num_backup_commands);
            if (message.num_new_commands != null && message.hasOwnProperty("num_new_commands"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num_new_commands);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_Move message, length delimited. Does not implicitly {@link CCLCMsg_Move.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {ICCLCMsg_Move} message CCLCMsg_Move message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_Move.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.num_backup_commands = reader.uint32();
                    break;
                case 2:
                    message.num_new_commands = reader.uint32();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_Move message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_Move
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_Move.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_Move message.
         * @function verify
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_Move.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.num_backup_commands != null && message.hasOwnProperty("num_backup_commands"))
                if (!$util.isInteger(message.num_backup_commands))
                    return "num_backup_commands: integer expected";
            if (message.num_new_commands != null && message.hasOwnProperty("num_new_commands"))
                if (!$util.isInteger(message.num_new_commands))
                    return "num_new_commands: integer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_Move message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_Move} CCLCMsg_Move
         */
        CCLCMsg_Move.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_Move)
                return object;
            var message = new $root.CCLCMsg_Move();
            if (object.num_backup_commands != null)
                message.num_backup_commands = object.num_backup_commands >>> 0;
            if (object.num_new_commands != null)
                message.num_new_commands = object.num_new_commands >>> 0;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_Move message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_Move
         * @static
         * @param {CCLCMsg_Move} message CCLCMsg_Move
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_Move.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.num_backup_commands = 0;
                object.num_new_commands = 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.num_backup_commands != null && message.hasOwnProperty("num_backup_commands"))
                object.num_backup_commands = message.num_backup_commands;
            if (message.num_new_commands != null && message.hasOwnProperty("num_new_commands"))
                object.num_new_commands = message.num_new_commands;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_Move to JSON.
         * @function toJSON
         * @memberof CCLCMsg_Move
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_Move.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_Move;
    })();
    
    $root.CCLCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CCLCMsg_VoiceData.
         * @exports ICCLCMsg_VoiceData
         * @interface ICCLCMsg_VoiceData
         * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data
         * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
         * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format
         * @property {number|null} [sequence_bytes] CCLCMsg_VoiceData sequence_bytes
         * @property {number|null} [section_number] CCLCMsg_VoiceData section_number
         * @property {number|null} [uncompressed_sample_offset] CCLCMsg_VoiceData uncompressed_sample_offset
         */
    
        /**
         * Constructs a new CCLCMsg_VoiceData.
         * @exports CCLCMsg_VoiceData
         * @classdesc Represents a CCLCMsg_VoiceData.
         * @implements ICCLCMsg_VoiceData
         * @constructor
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         */
        function CCLCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_VoiceData data.
         * @member {Uint8Array} data
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);
    
        /**
         * CCLCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CCLCMsg_VoiceData format.
         * @member {VoiceDataFormat_t} format
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.format = 1;
    
        /**
         * CCLCMsg_VoiceData sequence_bytes.
         * @member {number} sequence_bytes
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.sequence_bytes = 0;
    
        /**
         * CCLCMsg_VoiceData section_number.
         * @member {number} section_number
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.section_number = 0;
    
        /**
         * CCLCMsg_VoiceData uncompressed_sample_offset.
         * @member {number} uncompressed_sample_offset
         * @memberof CCLCMsg_VoiceData
         * @instance
         */
        CCLCMsg_VoiceData.prototype.uncompressed_sample_offset = 0;
    
        /**
         * Creates a new CCLCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData instance
         */
        CCLCMsg_VoiceData.create = function create(properties) {
            return new CCLCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.xuid);
            if (message.format != null && message.hasOwnProperty("format"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.format);
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sequence_bytes);
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.section_number);
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uncompressed_sample_offset);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_VoiceData message, length delimited. Does not implicitly {@link CCLCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {ICCLCMsg_VoiceData} message CCLCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.format = reader.int32();
                    break;
                case 4:
                    message.sequence_bytes = reader.int32();
                    break;
                case 5:
                    message.section_number = reader.uint32();
                    break;
                case 6:
                    message.uncompressed_sample_offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_VoiceData message.
         * @function verify
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                if (!$util.isInteger(message.sequence_bytes))
                    return "sequence_bytes: integer expected";
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                if (!$util.isInteger(message.section_number))
                    return "section_number: integer expected";
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                if (!$util.isInteger(message.uncompressed_sample_offset))
                    return "uncompressed_sample_offset: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
         */
        CCLCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_VoiceData)
                return object;
            var message = new $root.CCLCMsg_VoiceData();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            switch (object.format) {
            case "VOICEDATA_FORMAT_STEAM":
            case 0:
                message.format = 0;
                break;
            case "VOICEDATA_FORMAT_ENGINE":
            case 1:
                message.format = 1;
                break;
            }
            if (object.sequence_bytes != null)
                message.sequence_bytes = object.sequence_bytes | 0;
            if (object.section_number != null)
                message.section_number = object.section_number >>> 0;
            if (object.uncompressed_sample_offset != null)
                message.uncompressed_sample_offset = object.uncompressed_sample_offset >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_VoiceData
         * @static
         * @param {CCLCMsg_VoiceData} message CCLCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.format = options.enums === String ? "VOICEDATA_FORMAT_ENGINE" : 1;
                object.sequence_bytes = 0;
                object.section_number = 0;
                object.uncompressed_sample_offset = 0;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.VoiceDataFormat_t[message.format] : message.format;
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                object.sequence_bytes = message.sequence_bytes;
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                object.section_number = message.section_number;
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                object.uncompressed_sample_offset = message.uncompressed_sample_offset;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CCLCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_VoiceData;
    })();
    
    $root.CCLCMsg_BaselineAck = (function() {
    
        /**
         * Properties of a CCLCMsg_BaselineAck.
         * @exports ICCLCMsg_BaselineAck
         * @interface ICCLCMsg_BaselineAck
         * @property {number|null} [baseline_tick] CCLCMsg_BaselineAck baseline_tick
         * @property {number|null} [baseline_nr] CCLCMsg_BaselineAck baseline_nr
         */
    
        /**
         * Constructs a new CCLCMsg_BaselineAck.
         * @exports CCLCMsg_BaselineAck
         * @classdesc Represents a CCLCMsg_BaselineAck.
         * @implements ICCLCMsg_BaselineAck
         * @constructor
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         */
        function CCLCMsg_BaselineAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_BaselineAck baseline_tick.
         * @member {number} baseline_tick
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baseline_tick = 0;
    
        /**
         * CCLCMsg_BaselineAck baseline_nr.
         * @member {number} baseline_nr
         * @memberof CCLCMsg_BaselineAck
         * @instance
         */
        CCLCMsg_BaselineAck.prototype.baseline_nr = 0;
    
        /**
         * Creates a new CCLCMsg_BaselineAck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck instance
         */
        CCLCMsg_BaselineAck.create = function create(properties) {
            return new CCLCMsg_BaselineAck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.baseline_tick != null && message.hasOwnProperty("baseline_tick"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.baseline_tick);
            if (message.baseline_nr != null && message.hasOwnProperty("baseline_nr"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.baseline_nr);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_BaselineAck message, length delimited. Does not implicitly {@link CCLCMsg_BaselineAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {ICCLCMsg_BaselineAck} message CCLCMsg_BaselineAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_BaselineAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.baseline_tick = reader.int32();
                    break;
                case 2:
                    message.baseline_nr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_BaselineAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_BaselineAck message.
         * @function verify
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_BaselineAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.baseline_tick != null && message.hasOwnProperty("baseline_tick"))
                if (!$util.isInteger(message.baseline_tick))
                    return "baseline_tick: integer expected";
            if (message.baseline_nr != null && message.hasOwnProperty("baseline_nr"))
                if (!$util.isInteger(message.baseline_nr))
                    return "baseline_nr: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_BaselineAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
         */
        CCLCMsg_BaselineAck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_BaselineAck)
                return object;
            var message = new $root.CCLCMsg_BaselineAck();
            if (object.baseline_tick != null)
                message.baseline_tick = object.baseline_tick | 0;
            if (object.baseline_nr != null)
                message.baseline_nr = object.baseline_nr | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_BaselineAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_BaselineAck
         * @static
         * @param {CCLCMsg_BaselineAck} message CCLCMsg_BaselineAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_BaselineAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.baseline_tick = 0;
                object.baseline_nr = 0;
            }
            if (message.baseline_tick != null && message.hasOwnProperty("baseline_tick"))
                object.baseline_tick = message.baseline_tick;
            if (message.baseline_nr != null && message.hasOwnProperty("baseline_nr"))
                object.baseline_nr = message.baseline_nr;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_BaselineAck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_BaselineAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_BaselineAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_BaselineAck;
    })();
    
    $root.CCLCMsg_ListenEvents = (function() {
    
        /**
         * Properties of a CCLCMsg_ListenEvents.
         * @exports ICCLCMsg_ListenEvents
         * @interface ICCLCMsg_ListenEvents
         * @property {Array.<number>|null} [event_mask] CCLCMsg_ListenEvents event_mask
         */
    
        /**
         * Constructs a new CCLCMsg_ListenEvents.
         * @exports CCLCMsg_ListenEvents
         * @classdesc Represents a CCLCMsg_ListenEvents.
         * @implements ICCLCMsg_ListenEvents
         * @constructor
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         */
        function CCLCMsg_ListenEvents(properties) {
            this.event_mask = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_ListenEvents event_mask.
         * @member {Array.<number>} event_mask
         * @memberof CCLCMsg_ListenEvents
         * @instance
         */
        CCLCMsg_ListenEvents.prototype.event_mask = $util.emptyArray;
    
        /**
         * Creates a new CCLCMsg_ListenEvents instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents instance
         */
        CCLCMsg_ListenEvents.create = function create(properties) {
            return new CCLCMsg_ListenEvents(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_mask != null && message.event_mask.length)
                for (var i = 0; i < message.event_mask.length; ++i)
                    writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.event_mask[i]);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_ListenEvents message, length delimited. Does not implicitly {@link CCLCMsg_ListenEvents.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {ICCLCMsg_ListenEvents} message CCLCMsg_ListenEvents message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_ListenEvents.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.event_mask && message.event_mask.length))
                        message.event_mask = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.event_mask.push(reader.fixed32());
                    } else
                        message.event_mask.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_ListenEvents.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_ListenEvents message.
         * @function verify
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_ListenEvents.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_mask != null && message.hasOwnProperty("event_mask")) {
                if (!Array.isArray(message.event_mask))
                    return "event_mask: array expected";
                for (var i = 0; i < message.event_mask.length; ++i)
                    if (!$util.isInteger(message.event_mask[i]))
                        return "event_mask: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_ListenEvents message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
         */
        CCLCMsg_ListenEvents.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_ListenEvents)
                return object;
            var message = new $root.CCLCMsg_ListenEvents();
            if (object.event_mask) {
                if (!Array.isArray(object.event_mask))
                    throw TypeError(".CCLCMsg_ListenEvents.event_mask: array expected");
                message.event_mask = [];
                for (var i = 0; i < object.event_mask.length; ++i)
                    message.event_mask[i] = object.event_mask[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_ListenEvents message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_ListenEvents
         * @static
         * @param {CCLCMsg_ListenEvents} message CCLCMsg_ListenEvents
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_ListenEvents.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.event_mask = [];
            if (message.event_mask && message.event_mask.length) {
                object.event_mask = [];
                for (var j = 0; j < message.event_mask.length; ++j)
                    object.event_mask[j] = message.event_mask[j];
            }
            return object;
        };
    
        /**
         * Converts this CCLCMsg_ListenEvents to JSON.
         * @function toJSON
         * @memberof CCLCMsg_ListenEvents
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_ListenEvents.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_ListenEvents;
    })();
    
    $root.CCLCMsg_RespondCvarValue = (function() {
    
        /**
         * Properties of a CCLCMsg_RespondCvarValue.
         * @exports ICCLCMsg_RespondCvarValue
         * @interface ICCLCMsg_RespondCvarValue
         * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
         * @property {number|null} [status_code] CCLCMsg_RespondCvarValue status_code
         * @property {string|null} [name] CCLCMsg_RespondCvarValue name
         * @property {string|null} [value] CCLCMsg_RespondCvarValue value
         */
    
        /**
         * Constructs a new CCLCMsg_RespondCvarValue.
         * @exports CCLCMsg_RespondCvarValue
         * @classdesc Represents a CCLCMsg_RespondCvarValue.
         * @implements ICCLCMsg_RespondCvarValue
         * @constructor
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         */
        function CCLCMsg_RespondCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_RespondCvarValue cookie.
         * @member {number} cookie
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    
        /**
         * CCLCMsg_RespondCvarValue status_code.
         * @member {number} status_code
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.status_code = 0;
    
        /**
         * CCLCMsg_RespondCvarValue name.
         * @member {string} name
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.name = "";
    
        /**
         * CCLCMsg_RespondCvarValue value.
         * @member {string} value
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         */
        CCLCMsg_RespondCvarValue.prototype.value = "";
    
        /**
         * Creates a new CCLCMsg_RespondCvarValue instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue instance
         */
        CCLCMsg_RespondCvarValue.create = function create(properties) {
            return new CCLCMsg_RespondCvarValue(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.status_code != null && message.hasOwnProperty("status_code"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status_code);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_RespondCvarValue message, length delimited. Does not implicitly {@link CCLCMsg_RespondCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {ICCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_RespondCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.status_code = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_RespondCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_RespondCvarValue message.
         * @function verify
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_RespondCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.status_code != null && message.hasOwnProperty("status_code"))
                if (!$util.isInteger(message.status_code))
                    return "status_code: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_RespondCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
         */
        CCLCMsg_RespondCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_RespondCvarValue)
                return object;
            var message = new $root.CCLCMsg_RespondCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.status_code != null)
                message.status_code = object.status_code | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_RespondCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_RespondCvarValue
         * @static
         * @param {CCLCMsg_RespondCvarValue} message CCLCMsg_RespondCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_RespondCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.status_code = 0;
                object.name = "";
                object.value = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.status_code != null && message.hasOwnProperty("status_code"))
                object.status_code = message.status_code;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_RespondCvarValue to JSON.
         * @function toJSON
         * @memberof CCLCMsg_RespondCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_RespondCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_RespondCvarValue;
    })();
    
    $root.CCLCMsg_FileCRCCheck = (function() {
    
        /**
         * Properties of a CCLCMsg_FileCRCCheck.
         * @exports ICCLCMsg_FileCRCCheck
         * @interface ICCLCMsg_FileCRCCheck
         * @property {number|null} [code_path] CCLCMsg_FileCRCCheck code_path
         * @property {string|null} [path] CCLCMsg_FileCRCCheck path
         * @property {number|null} [code_filename] CCLCMsg_FileCRCCheck code_filename
         * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
         * @property {number|null} [file_fraction] CCLCMsg_FileCRCCheck file_fraction
         * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5
         * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
         * @property {number|null} [file_hash_type] CCLCMsg_FileCRCCheck file_hash_type
         * @property {number|null} [file_len] CCLCMsg_FileCRCCheck file_len
         * @property {number|null} [pack_file_id] CCLCMsg_FileCRCCheck pack_file_id
         * @property {number|null} [pack_file_number] CCLCMsg_FileCRCCheck pack_file_number
         */
    
        /**
         * Constructs a new CCLCMsg_FileCRCCheck.
         * @exports CCLCMsg_FileCRCCheck
         * @classdesc Represents a CCLCMsg_FileCRCCheck.
         * @implements ICCLCMsg_FileCRCCheck
         * @constructor
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         */
        function CCLCMsg_FileCRCCheck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_FileCRCCheck code_path.
         * @member {number} code_path
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.code_path = 0;
    
        /**
         * CCLCMsg_FileCRCCheck path.
         * @member {string} path
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.path = "";
    
        /**
         * CCLCMsg_FileCRCCheck code_filename.
         * @member {number} code_filename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.code_filename = 0;
    
        /**
         * CCLCMsg_FileCRCCheck filename.
         * @member {string} filename
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.filename = "";
    
        /**
         * CCLCMsg_FileCRCCheck file_fraction.
         * @member {number} file_fraction
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.file_fraction = 0;
    
        /**
         * CCLCMsg_FileCRCCheck md5.
         * @member {Uint8Array} md5
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);
    
        /**
         * CCLCMsg_FileCRCCheck crc.
         * @member {number} crc
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.crc = 0;
    
        /**
         * CCLCMsg_FileCRCCheck file_hash_type.
         * @member {number} file_hash_type
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.file_hash_type = 0;
    
        /**
         * CCLCMsg_FileCRCCheck file_len.
         * @member {number} file_len
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.file_len = 0;
    
        /**
         * CCLCMsg_FileCRCCheck pack_file_id.
         * @member {number} pack_file_id
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.pack_file_id = 0;
    
        /**
         * CCLCMsg_FileCRCCheck pack_file_number.
         * @member {number} pack_file_number
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         */
        CCLCMsg_FileCRCCheck.prototype.pack_file_number = 0;
    
        /**
         * Creates a new CCLCMsg_FileCRCCheck instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck instance
         */
        CCLCMsg_FileCRCCheck.create = function create(properties) {
            return new CCLCMsg_FileCRCCheck(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code_path != null && message.hasOwnProperty("code_path"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code_path);
            if (message.path != null && message.hasOwnProperty("path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.code_filename != null && message.hasOwnProperty("code_filename"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code_filename);
            if (message.filename != null && message.hasOwnProperty("filename"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.filename);
            if (message.file_fraction != null && message.hasOwnProperty("file_fraction"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.file_fraction);
            if (message.md5 != null && message.hasOwnProperty("md5"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.md5);
            if (message.crc != null && message.hasOwnProperty("crc"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.crc);
            if (message.file_hash_type != null && message.hasOwnProperty("file_hash_type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.file_hash_type);
            if (message.file_len != null && message.hasOwnProperty("file_len"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.file_len);
            if (message.pack_file_id != null && message.hasOwnProperty("pack_file_id"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pack_file_id);
            if (message.pack_file_number != null && message.hasOwnProperty("pack_file_number"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.pack_file_number);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_FileCRCCheck message, length delimited. Does not implicitly {@link CCLCMsg_FileCRCCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {ICCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_FileCRCCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code_path = reader.int32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.code_filename = reader.int32();
                    break;
                case 4:
                    message.filename = reader.string();
                    break;
                case 5:
                    message.file_fraction = reader.int32();
                    break;
                case 6:
                    message.md5 = reader.bytes();
                    break;
                case 7:
                    message.crc = reader.uint32();
                    break;
                case 8:
                    message.file_hash_type = reader.int32();
                    break;
                case 9:
                    message.file_len = reader.int32();
                    break;
                case 10:
                    message.pack_file_id = reader.int32();
                    break;
                case 11:
                    message.pack_file_number = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_FileCRCCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_FileCRCCheck message.
         * @function verify
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_FileCRCCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code_path != null && message.hasOwnProperty("code_path"))
                if (!$util.isInteger(message.code_path))
                    return "code_path: integer expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.code_filename != null && message.hasOwnProperty("code_filename"))
                if (!$util.isInteger(message.code_filename))
                    return "code_filename: integer expected";
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            if (message.file_fraction != null && message.hasOwnProperty("file_fraction"))
                if (!$util.isInteger(message.file_fraction))
                    return "file_fraction: integer expected";
            if (message.md5 != null && message.hasOwnProperty("md5"))
                if (!(message.md5 && typeof message.md5.length === "number" || $util.isString(message.md5)))
                    return "md5: buffer expected";
            if (message.crc != null && message.hasOwnProperty("crc"))
                if (!$util.isInteger(message.crc))
                    return "crc: integer expected";
            if (message.file_hash_type != null && message.hasOwnProperty("file_hash_type"))
                if (!$util.isInteger(message.file_hash_type))
                    return "file_hash_type: integer expected";
            if (message.file_len != null && message.hasOwnProperty("file_len"))
                if (!$util.isInteger(message.file_len))
                    return "file_len: integer expected";
            if (message.pack_file_id != null && message.hasOwnProperty("pack_file_id"))
                if (!$util.isInteger(message.pack_file_id))
                    return "pack_file_id: integer expected";
            if (message.pack_file_number != null && message.hasOwnProperty("pack_file_number"))
                if (!$util.isInteger(message.pack_file_number))
                    return "pack_file_number: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_FileCRCCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
         */
        CCLCMsg_FileCRCCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_FileCRCCheck)
                return object;
            var message = new $root.CCLCMsg_FileCRCCheck();
            if (object.code_path != null)
                message.code_path = object.code_path | 0;
            if (object.path != null)
                message.path = String(object.path);
            if (object.code_filename != null)
                message.code_filename = object.code_filename | 0;
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.file_fraction != null)
                message.file_fraction = object.file_fraction | 0;
            if (object.md5 != null)
                if (typeof object.md5 === "string")
                    $util.base64.decode(object.md5, message.md5 = $util.newBuffer($util.base64.length(object.md5)), 0);
                else if (object.md5.length)
                    message.md5 = object.md5;
            if (object.crc != null)
                message.crc = object.crc >>> 0;
            if (object.file_hash_type != null)
                message.file_hash_type = object.file_hash_type | 0;
            if (object.file_len != null)
                message.file_len = object.file_len | 0;
            if (object.pack_file_id != null)
                message.pack_file_id = object.pack_file_id | 0;
            if (object.pack_file_number != null)
                message.pack_file_number = object.pack_file_number | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_FileCRCCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_FileCRCCheck
         * @static
         * @param {CCLCMsg_FileCRCCheck} message CCLCMsg_FileCRCCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_FileCRCCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code_path = 0;
                object.path = "";
                object.code_filename = 0;
                object.filename = "";
                object.file_fraction = 0;
                if (options.bytes === String)
                    object.md5 = "";
                else {
                    object.md5 = [];
                    if (options.bytes !== Array)
                        object.md5 = $util.newBuffer(object.md5);
                }
                object.crc = 0;
                object.file_hash_type = 0;
                object.file_len = 0;
                object.pack_file_id = 0;
                object.pack_file_number = 0;
            }
            if (message.code_path != null && message.hasOwnProperty("code_path"))
                object.code_path = message.code_path;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.code_filename != null && message.hasOwnProperty("code_filename"))
                object.code_filename = message.code_filename;
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.file_fraction != null && message.hasOwnProperty("file_fraction"))
                object.file_fraction = message.file_fraction;
            if (message.md5 != null && message.hasOwnProperty("md5"))
                object.md5 = options.bytes === String ? $util.base64.encode(message.md5, 0, message.md5.length) : options.bytes === Array ? Array.prototype.slice.call(message.md5) : message.md5;
            if (message.crc != null && message.hasOwnProperty("crc"))
                object.crc = message.crc;
            if (message.file_hash_type != null && message.hasOwnProperty("file_hash_type"))
                object.file_hash_type = message.file_hash_type;
            if (message.file_len != null && message.hasOwnProperty("file_len"))
                object.file_len = message.file_len;
            if (message.pack_file_id != null && message.hasOwnProperty("pack_file_id"))
                object.pack_file_id = message.pack_file_id;
            if (message.pack_file_number != null && message.hasOwnProperty("pack_file_number"))
                object.pack_file_number = message.pack_file_number;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_FileCRCCheck to JSON.
         * @function toJSON
         * @memberof CCLCMsg_FileCRCCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_FileCRCCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_FileCRCCheck;
    })();
    
    $root.CCLCMsg_LoadingProgress = (function() {
    
        /**
         * Properties of a CCLCMsg_LoadingProgress.
         * @exports ICCLCMsg_LoadingProgress
         * @interface ICCLCMsg_LoadingProgress
         * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
         */
    
        /**
         * Constructs a new CCLCMsg_LoadingProgress.
         * @exports CCLCMsg_LoadingProgress
         * @classdesc Represents a CCLCMsg_LoadingProgress.
         * @implements ICCLCMsg_LoadingProgress
         * @constructor
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         */
        function CCLCMsg_LoadingProgress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_LoadingProgress progress.
         * @member {number} progress
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         */
        CCLCMsg_LoadingProgress.prototype.progress = 0;
    
        /**
         * Creates a new CCLCMsg_LoadingProgress instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress instance
         */
        CCLCMsg_LoadingProgress.create = function create(properties) {
            return new CCLCMsg_LoadingProgress(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.progress != null && message.hasOwnProperty("progress"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.progress);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_LoadingProgress message, length delimited. Does not implicitly {@link CCLCMsg_LoadingProgress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {ICCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_LoadingProgress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_LoadingProgress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_LoadingProgress message.
         * @function verify
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_LoadingProgress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.progress != null && message.hasOwnProperty("progress"))
                if (!$util.isInteger(message.progress))
                    return "progress: integer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_LoadingProgress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
         */
        CCLCMsg_LoadingProgress.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_LoadingProgress)
                return object;
            var message = new $root.CCLCMsg_LoadingProgress();
            if (object.progress != null)
                message.progress = object.progress | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_LoadingProgress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_LoadingProgress
         * @static
         * @param {CCLCMsg_LoadingProgress} message CCLCMsg_LoadingProgress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_LoadingProgress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.progress = 0;
            if (message.progress != null && message.hasOwnProperty("progress"))
                object.progress = message.progress;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_LoadingProgress to JSON.
         * @function toJSON
         * @memberof CCLCMsg_LoadingProgress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_LoadingProgress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_LoadingProgress;
    })();
    
    $root.CCLCMsg_SplitPlayerConnect = (function() {
    
        /**
         * Properties of a CCLCMsg_SplitPlayerConnect.
         * @exports ICCLCMsg_SplitPlayerConnect
         * @interface ICCLCMsg_SplitPlayerConnect
         * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars
         */
    
        /**
         * Constructs a new CCLCMsg_SplitPlayerConnect.
         * @exports CCLCMsg_SplitPlayerConnect
         * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
         * @implements ICCLCMsg_SplitPlayerConnect
         * @constructor
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         */
        function CCLCMsg_SplitPlayerConnect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_SplitPlayerConnect convars.
         * @member {ICMsg_CVars|null|undefined} convars
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         */
        CCLCMsg_SplitPlayerConnect.prototype.convars = null;
    
        /**
         * Creates a new CCLCMsg_SplitPlayerConnect instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect instance
         */
        CCLCMsg_SplitPlayerConnect.create = function create(properties) {
            return new CCLCMsg_SplitPlayerConnect(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.convars != null && message.hasOwnProperty("convars"))
                $root.CMsg_CVars.encode(message.convars, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_SplitPlayerConnect message, length delimited. Does not implicitly {@link CCLCMsg_SplitPlayerConnect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {ICCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_SplitPlayerConnect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_SplitPlayerConnect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_SplitPlayerConnect message.
         * @function verify
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_SplitPlayerConnect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.convars != null && message.hasOwnProperty("convars")) {
                var error = $root.CMsg_CVars.verify(message.convars);
                if (error)
                    return "convars." + error;
            }
            return null;
        };
    
        /**
         * Creates a CCLCMsg_SplitPlayerConnect message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
         */
        CCLCMsg_SplitPlayerConnect.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_SplitPlayerConnect)
                return object;
            var message = new $root.CCLCMsg_SplitPlayerConnect();
            if (object.convars != null) {
                if (typeof object.convars !== "object")
                    throw TypeError(".CCLCMsg_SplitPlayerConnect.convars: object expected");
                message.convars = $root.CMsg_CVars.fromObject(object.convars);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_SplitPlayerConnect message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_SplitPlayerConnect
         * @static
         * @param {CCLCMsg_SplitPlayerConnect} message CCLCMsg_SplitPlayerConnect
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_SplitPlayerConnect.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.convars = null;
            if (message.convars != null && message.hasOwnProperty("convars"))
                object.convars = $root.CMsg_CVars.toObject(message.convars, options);
            return object;
        };
    
        /**
         * Converts this CCLCMsg_SplitPlayerConnect to JSON.
         * @function toJSON
         * @memberof CCLCMsg_SplitPlayerConnect
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_SplitPlayerConnect.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_SplitPlayerConnect;
    })();
    
    $root.CCLCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CCLCMsg_CmdKeyValues.
         * @exports ICCLCMsg_CmdKeyValues
         * @interface ICCLCMsg_CmdKeyValues
         * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues
         */
    
        /**
         * Constructs a new CCLCMsg_CmdKeyValues.
         * @exports CCLCMsg_CmdKeyValues
         * @classdesc Represents a CCLCMsg_CmdKeyValues.
         * @implements ICCLCMsg_CmdKeyValues
         * @constructor
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CCLCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_CmdKeyValues keyvalues.
         * @member {Uint8Array} keyvalues
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         */
        CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    
        /**
         * Creates a new CCLCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues instance
         */
        CCLCMsg_CmdKeyValues.create = function create(properties) {
            return new CCLCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyvalues);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CCLCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {ICCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                if (!(message.keyvalues && typeof message.keyvalues.length === "number" || $util.isString(message.keyvalues)))
                    return "keyvalues: buffer expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
         */
        CCLCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_CmdKeyValues)
                return object;
            var message = new $root.CCLCMsg_CmdKeyValues();
            if (object.keyvalues != null)
                if (typeof object.keyvalues === "string")
                    $util.base64.decode(object.keyvalues, message.keyvalues = $util.newBuffer($util.base64.length(object.keyvalues)), 0);
                else if (object.keyvalues.length)
                    message.keyvalues = object.keyvalues;
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_CmdKeyValues
         * @static
         * @param {CCLCMsg_CmdKeyValues} message CCLCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.keyvalues = "";
                else {
                    object.keyvalues = [];
                    if (options.bytes !== Array)
                        object.keyvalues = $util.newBuffer(object.keyvalues);
                }
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                object.keyvalues = options.bytes === String ? $util.base64.encode(message.keyvalues, 0, message.keyvalues.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyvalues) : message.keyvalues;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CCLCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_CmdKeyValues;
    })();
    
    $root.CSVCMsg_ServerInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ServerInfo.
         * @exports ICSVCMsg_ServerInfo
         * @interface ICSVCMsg_ServerInfo
         * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
         * @property {number|null} [server_count] CSVCMsg_ServerInfo server_count
         * @property {boolean|null} [is_dedicated] CSVCMsg_ServerInfo is_dedicated
         * @property {boolean|null} [is_official_valve_server] CSVCMsg_ServerInfo is_official_valve_server
         * @property {boolean|null} [is_hltv] CSVCMsg_ServerInfo is_hltv
         * @property {boolean|null} [is_replay] CSVCMsg_ServerInfo is_replay
         * @property {boolean|null} [is_redirecting_to_proxy_relay] CSVCMsg_ServerInfo is_redirecting_to_proxy_relay
         * @property {number|null} [c_os] CSVCMsg_ServerInfo c_os
         * @property {number|null} [map_crc] CSVCMsg_ServerInfo map_crc
         * @property {number|null} [client_crc] CSVCMsg_ServerInfo client_crc
         * @property {number|null} [string_table_crc] CSVCMsg_ServerInfo string_table_crc
         * @property {number|null} [max_clients] CSVCMsg_ServerInfo max_clients
         * @property {number|null} [max_classes] CSVCMsg_ServerInfo max_classes
         * @property {number|null} [player_slot] CSVCMsg_ServerInfo player_slot
         * @property {number|null} [tick_interval] CSVCMsg_ServerInfo tick_interval
         * @property {string|null} [game_dir] CSVCMsg_ServerInfo game_dir
         * @property {string|null} [map_name] CSVCMsg_ServerInfo map_name
         * @property {string|null} [map_group_name] CSVCMsg_ServerInfo map_group_name
         * @property {string|null} [sky_name] CSVCMsg_ServerInfo sky_name
         * @property {string|null} [host_name] CSVCMsg_ServerInfo host_name
         * @property {number|null} [public_ip] CSVCMsg_ServerInfo public_ip
         * @property {number|Long|null} [ugc_map_id] CSVCMsg_ServerInfo ugc_map_id
         */
    
        /**
         * Constructs a new CSVCMsg_ServerInfo.
         * @exports CSVCMsg_ServerInfo
         * @classdesc Represents a CSVCMsg_ServerInfo.
         * @implements ICSVCMsg_ServerInfo
         * @constructor
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         */
        function CSVCMsg_ServerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ServerInfo protocol.
         * @member {number} protocol
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.protocol = 0;
    
        /**
         * CSVCMsg_ServerInfo server_count.
         * @member {number} server_count
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.server_count = 0;
    
        /**
         * CSVCMsg_ServerInfo is_dedicated.
         * @member {boolean} is_dedicated
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_dedicated = false;
    
        /**
         * CSVCMsg_ServerInfo is_official_valve_server.
         * @member {boolean} is_official_valve_server
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_official_valve_server = false;
    
        /**
         * CSVCMsg_ServerInfo is_hltv.
         * @member {boolean} is_hltv
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_hltv = false;
    
        /**
         * CSVCMsg_ServerInfo is_replay.
         * @member {boolean} is_replay
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_replay = false;
    
        /**
         * CSVCMsg_ServerInfo is_redirecting_to_proxy_relay.
         * @member {boolean} is_redirecting_to_proxy_relay
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.is_redirecting_to_proxy_relay = false;
    
        /**
         * CSVCMsg_ServerInfo c_os.
         * @member {number} c_os
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.c_os = 0;
    
        /**
         * CSVCMsg_ServerInfo map_crc.
         * @member {number} map_crc
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.map_crc = 0;
    
        /**
         * CSVCMsg_ServerInfo client_crc.
         * @member {number} client_crc
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.client_crc = 0;
    
        /**
         * CSVCMsg_ServerInfo string_table_crc.
         * @member {number} string_table_crc
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.string_table_crc = 0;
    
        /**
         * CSVCMsg_ServerInfo max_clients.
         * @member {number} max_clients
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.max_clients = 0;
    
        /**
         * CSVCMsg_ServerInfo max_classes.
         * @member {number} max_classes
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.max_classes = 0;
    
        /**
         * CSVCMsg_ServerInfo player_slot.
         * @member {number} player_slot
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.player_slot = 0;
    
        /**
         * CSVCMsg_ServerInfo tick_interval.
         * @member {number} tick_interval
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.tick_interval = 0;
    
        /**
         * CSVCMsg_ServerInfo game_dir.
         * @member {string} game_dir
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.game_dir = "";
    
        /**
         * CSVCMsg_ServerInfo map_name.
         * @member {string} map_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.map_name = "";
    
        /**
         * CSVCMsg_ServerInfo map_group_name.
         * @member {string} map_group_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.map_group_name = "";
    
        /**
         * CSVCMsg_ServerInfo sky_name.
         * @member {string} sky_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.sky_name = "";
    
        /**
         * CSVCMsg_ServerInfo host_name.
         * @member {string} host_name
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.host_name = "";
    
        /**
         * CSVCMsg_ServerInfo public_ip.
         * @member {number} public_ip
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.public_ip = 0;
    
        /**
         * CSVCMsg_ServerInfo ugc_map_id.
         * @member {number|Long} ugc_map_id
         * @memberof CSVCMsg_ServerInfo
         * @instance
         */
        CSVCMsg_ServerInfo.prototype.ugc_map_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * Creates a new CSVCMsg_ServerInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo instance
         */
        CSVCMsg_ServerInfo.create = function create(properties) {
            return new CSVCMsg_ServerInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.server_count);
            if (message.is_dedicated != null && message.hasOwnProperty("is_dedicated"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_dedicated);
            if (message.is_official_valve_server != null && message.hasOwnProperty("is_official_valve_server"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.is_official_valve_server);
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.is_hltv);
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.is_replay);
            if (message.c_os != null && message.hasOwnProperty("c_os"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.c_os);
            if (message.map_crc != null && message.hasOwnProperty("map_crc"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.map_crc);
            if (message.client_crc != null && message.hasOwnProperty("client_crc"))
                writer.uint32(/* id 9, wireType 5 =*/77).fixed32(message.client_crc);
            if (message.string_table_crc != null && message.hasOwnProperty("string_table_crc"))
                writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.string_table_crc);
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.max_clients);
            if (message.max_classes != null && message.hasOwnProperty("max_classes"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.max_classes);
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.player_slot);
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.tick_interval);
            if (message.game_dir != null && message.hasOwnProperty("game_dir"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.game_dir);
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.map_name);
            if (message.map_group_name != null && message.hasOwnProperty("map_group_name"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.map_group_name);
            if (message.sky_name != null && message.hasOwnProperty("sky_name"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.sky_name);
            if (message.host_name != null && message.hasOwnProperty("host_name"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.host_name);
            if (message.public_ip != null && message.hasOwnProperty("public_ip"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.public_ip);
            if (message.is_redirecting_to_proxy_relay != null && message.hasOwnProperty("is_redirecting_to_proxy_relay"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.is_redirecting_to_proxy_relay);
            if (message.ugc_map_id != null && message.hasOwnProperty("ugc_map_id"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.ugc_map_id);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ServerInfo message, length delimited. Does not implicitly {@link CSVCMsg_ServerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {ICSVCMsg_ServerInfo} message CSVCMsg_ServerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ServerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.server_count = reader.int32();
                    break;
                case 3:
                    message.is_dedicated = reader.bool();
                    break;
                case 4:
                    message.is_official_valve_server = reader.bool();
                    break;
                case 5:
                    message.is_hltv = reader.bool();
                    break;
                case 6:
                    message.is_replay = reader.bool();
                    break;
                case 21:
                    message.is_redirecting_to_proxy_relay = reader.bool();
                    break;
                case 7:
                    message.c_os = reader.int32();
                    break;
                case 8:
                    message.map_crc = reader.fixed32();
                    break;
                case 9:
                    message.client_crc = reader.fixed32();
                    break;
                case 10:
                    message.string_table_crc = reader.fixed32();
                    break;
                case 11:
                    message.max_clients = reader.int32();
                    break;
                case 12:
                    message.max_classes = reader.int32();
                    break;
                case 13:
                    message.player_slot = reader.int32();
                    break;
                case 14:
                    message.tick_interval = reader.float();
                    break;
                case 15:
                    message.game_dir = reader.string();
                    break;
                case 16:
                    message.map_name = reader.string();
                    break;
                case 17:
                    message.map_group_name = reader.string();
                    break;
                case 18:
                    message.sky_name = reader.string();
                    break;
                case 19:
                    message.host_name = reader.string();
                    break;
                case 20:
                    message.public_ip = reader.uint32();
                    break;
                case 22:
                    message.ugc_map_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ServerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ServerInfo message.
         * @function verify
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ServerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isInteger(message.protocol))
                    return "protocol: integer expected";
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                if (!$util.isInteger(message.server_count))
                    return "server_count: integer expected";
            if (message.is_dedicated != null && message.hasOwnProperty("is_dedicated"))
                if (typeof message.is_dedicated !== "boolean")
                    return "is_dedicated: boolean expected";
            if (message.is_official_valve_server != null && message.hasOwnProperty("is_official_valve_server"))
                if (typeof message.is_official_valve_server !== "boolean")
                    return "is_official_valve_server: boolean expected";
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                if (typeof message.is_hltv !== "boolean")
                    return "is_hltv: boolean expected";
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                if (typeof message.is_replay !== "boolean")
                    return "is_replay: boolean expected";
            if (message.is_redirecting_to_proxy_relay != null && message.hasOwnProperty("is_redirecting_to_proxy_relay"))
                if (typeof message.is_redirecting_to_proxy_relay !== "boolean")
                    return "is_redirecting_to_proxy_relay: boolean expected";
            if (message.c_os != null && message.hasOwnProperty("c_os"))
                if (!$util.isInteger(message.c_os))
                    return "c_os: integer expected";
            if (message.map_crc != null && message.hasOwnProperty("map_crc"))
                if (!$util.isInteger(message.map_crc))
                    return "map_crc: integer expected";
            if (message.client_crc != null && message.hasOwnProperty("client_crc"))
                if (!$util.isInteger(message.client_crc))
                    return "client_crc: integer expected";
            if (message.string_table_crc != null && message.hasOwnProperty("string_table_crc"))
                if (!$util.isInteger(message.string_table_crc))
                    return "string_table_crc: integer expected";
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                if (!$util.isInteger(message.max_clients))
                    return "max_clients: integer expected";
            if (message.max_classes != null && message.hasOwnProperty("max_classes"))
                if (!$util.isInteger(message.max_classes))
                    return "max_classes: integer expected";
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                if (!$util.isInteger(message.player_slot))
                    return "player_slot: integer expected";
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                if (typeof message.tick_interval !== "number")
                    return "tick_interval: number expected";
            if (message.game_dir != null && message.hasOwnProperty("game_dir"))
                if (!$util.isString(message.game_dir))
                    return "game_dir: string expected";
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                if (!$util.isString(message.map_name))
                    return "map_name: string expected";
            if (message.map_group_name != null && message.hasOwnProperty("map_group_name"))
                if (!$util.isString(message.map_group_name))
                    return "map_group_name: string expected";
            if (message.sky_name != null && message.hasOwnProperty("sky_name"))
                if (!$util.isString(message.sky_name))
                    return "sky_name: string expected";
            if (message.host_name != null && message.hasOwnProperty("host_name"))
                if (!$util.isString(message.host_name))
                    return "host_name: string expected";
            if (message.public_ip != null && message.hasOwnProperty("public_ip"))
                if (!$util.isInteger(message.public_ip))
                    return "public_ip: integer expected";
            if (message.ugc_map_id != null && message.hasOwnProperty("ugc_map_id"))
                if (!$util.isInteger(message.ugc_map_id) && !(message.ugc_map_id && $util.isInteger(message.ugc_map_id.low) && $util.isInteger(message.ugc_map_id.high)))
                    return "ugc_map_id: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ServerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
         */
        CSVCMsg_ServerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ServerInfo)
                return object;
            var message = new $root.CSVCMsg_ServerInfo();
            if (object.protocol != null)
                message.protocol = object.protocol | 0;
            if (object.server_count != null)
                message.server_count = object.server_count | 0;
            if (object.is_dedicated != null)
                message.is_dedicated = Boolean(object.is_dedicated);
            if (object.is_official_valve_server != null)
                message.is_official_valve_server = Boolean(object.is_official_valve_server);
            if (object.is_hltv != null)
                message.is_hltv = Boolean(object.is_hltv);
            if (object.is_replay != null)
                message.is_replay = Boolean(object.is_replay);
            if (object.is_redirecting_to_proxy_relay != null)
                message.is_redirecting_to_proxy_relay = Boolean(object.is_redirecting_to_proxy_relay);
            if (object.c_os != null)
                message.c_os = object.c_os | 0;
            if (object.map_crc != null)
                message.map_crc = object.map_crc >>> 0;
            if (object.client_crc != null)
                message.client_crc = object.client_crc >>> 0;
            if (object.string_table_crc != null)
                message.string_table_crc = object.string_table_crc >>> 0;
            if (object.max_clients != null)
                message.max_clients = object.max_clients | 0;
            if (object.max_classes != null)
                message.max_classes = object.max_classes | 0;
            if (object.player_slot != null)
                message.player_slot = object.player_slot | 0;
            if (object.tick_interval != null)
                message.tick_interval = Number(object.tick_interval);
            if (object.game_dir != null)
                message.game_dir = String(object.game_dir);
            if (object.map_name != null)
                message.map_name = String(object.map_name);
            if (object.map_group_name != null)
                message.map_group_name = String(object.map_group_name);
            if (object.sky_name != null)
                message.sky_name = String(object.sky_name);
            if (object.host_name != null)
                message.host_name = String(object.host_name);
            if (object.public_ip != null)
                message.public_ip = object.public_ip >>> 0;
            if (object.ugc_map_id != null)
                if ($util.Long)
                    (message.ugc_map_id = $util.Long.fromValue(object.ugc_map_id)).unsigned = true;
                else if (typeof object.ugc_map_id === "string")
                    message.ugc_map_id = parseInt(object.ugc_map_id, 10);
                else if (typeof object.ugc_map_id === "number")
                    message.ugc_map_id = object.ugc_map_id;
                else if (typeof object.ugc_map_id === "object")
                    message.ugc_map_id = new $util.LongBits(object.ugc_map_id.low >>> 0, object.ugc_map_id.high >>> 0).toNumber(true);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ServerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ServerInfo
         * @static
         * @param {CSVCMsg_ServerInfo} message CSVCMsg_ServerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ServerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.protocol = 0;
                object.server_count = 0;
                object.is_dedicated = false;
                object.is_official_valve_server = false;
                object.is_hltv = false;
                object.is_replay = false;
                object.c_os = 0;
                object.map_crc = 0;
                object.client_crc = 0;
                object.string_table_crc = 0;
                object.max_clients = 0;
                object.max_classes = 0;
                object.player_slot = 0;
                object.tick_interval = 0;
                object.game_dir = "";
                object.map_name = "";
                object.map_group_name = "";
                object.sky_name = "";
                object.host_name = "";
                object.public_ip = 0;
                object.is_redirecting_to_proxy_relay = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ugc_map_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ugc_map_id = options.longs === String ? "0" : 0;
            }
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.server_count != null && message.hasOwnProperty("server_count"))
                object.server_count = message.server_count;
            if (message.is_dedicated != null && message.hasOwnProperty("is_dedicated"))
                object.is_dedicated = message.is_dedicated;
            if (message.is_official_valve_server != null && message.hasOwnProperty("is_official_valve_server"))
                object.is_official_valve_server = message.is_official_valve_server;
            if (message.is_hltv != null && message.hasOwnProperty("is_hltv"))
                object.is_hltv = message.is_hltv;
            if (message.is_replay != null && message.hasOwnProperty("is_replay"))
                object.is_replay = message.is_replay;
            if (message.c_os != null && message.hasOwnProperty("c_os"))
                object.c_os = message.c_os;
            if (message.map_crc != null && message.hasOwnProperty("map_crc"))
                object.map_crc = message.map_crc;
            if (message.client_crc != null && message.hasOwnProperty("client_crc"))
                object.client_crc = message.client_crc;
            if (message.string_table_crc != null && message.hasOwnProperty("string_table_crc"))
                object.string_table_crc = message.string_table_crc;
            if (message.max_clients != null && message.hasOwnProperty("max_clients"))
                object.max_clients = message.max_clients;
            if (message.max_classes != null && message.hasOwnProperty("max_classes"))
                object.max_classes = message.max_classes;
            if (message.player_slot != null && message.hasOwnProperty("player_slot"))
                object.player_slot = message.player_slot;
            if (message.tick_interval != null && message.hasOwnProperty("tick_interval"))
                object.tick_interval = options.json && !isFinite(message.tick_interval) ? String(message.tick_interval) : message.tick_interval;
            if (message.game_dir != null && message.hasOwnProperty("game_dir"))
                object.game_dir = message.game_dir;
            if (message.map_name != null && message.hasOwnProperty("map_name"))
                object.map_name = message.map_name;
            if (message.map_group_name != null && message.hasOwnProperty("map_group_name"))
                object.map_group_name = message.map_group_name;
            if (message.sky_name != null && message.hasOwnProperty("sky_name"))
                object.sky_name = message.sky_name;
            if (message.host_name != null && message.hasOwnProperty("host_name"))
                object.host_name = message.host_name;
            if (message.public_ip != null && message.hasOwnProperty("public_ip"))
                object.public_ip = message.public_ip;
            if (message.is_redirecting_to_proxy_relay != null && message.hasOwnProperty("is_redirecting_to_proxy_relay"))
                object.is_redirecting_to_proxy_relay = message.is_redirecting_to_proxy_relay;
            if (message.ugc_map_id != null && message.hasOwnProperty("ugc_map_id"))
                if (typeof message.ugc_map_id === "number")
                    object.ugc_map_id = options.longs === String ? String(message.ugc_map_id) : message.ugc_map_id;
                else
                    object.ugc_map_id = options.longs === String ? $util.Long.prototype.toString.call(message.ugc_map_id) : options.longs === Number ? new $util.LongBits(message.ugc_map_id.low >>> 0, message.ugc_map_id.high >>> 0).toNumber(true) : message.ugc_map_id;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ServerInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ServerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ServerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_ServerInfo;
    })();
    
    $root.CSVCMsg_ClassInfo = (function() {
    
        /**
         * Properties of a CSVCMsg_ClassInfo.
         * @exports ICSVCMsg_ClassInfo
         * @interface ICSVCMsg_ClassInfo
         * @property {boolean|null} [create_on_client] CSVCMsg_ClassInfo create_on_client
         * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
         */
    
        /**
         * Constructs a new CSVCMsg_ClassInfo.
         * @exports CSVCMsg_ClassInfo
         * @classdesc Represents a CSVCMsg_ClassInfo.
         * @implements ICSVCMsg_ClassInfo
         * @constructor
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         */
        function CSVCMsg_ClassInfo(properties) {
            this.classes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_ClassInfo create_on_client.
         * @member {boolean} create_on_client
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.create_on_client = false;
    
        /**
         * CSVCMsg_ClassInfo classes.
         * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
         * @memberof CSVCMsg_ClassInfo
         * @instance
         */
        CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_ClassInfo instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo instance
         */
        CSVCMsg_ClassInfo.create = function create(properties) {
            return new CSVCMsg_ClassInfo(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.create_on_client != null && message.hasOwnProperty("create_on_client"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.create_on_client);
            if (message.classes != null && message.classes.length)
                for (var i = 0; i < message.classes.length; ++i)
                    $root.CSVCMsg_ClassInfo.class_t.encode(message.classes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_ClassInfo message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {ICSVCMsg_ClassInfo} message CSVCMsg_ClassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_ClassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.create_on_client = reader.bool();
                    break;
                case 2:
                    if (!(message.classes && message.classes.length))
                        message.classes = [];
                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_ClassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_ClassInfo message.
         * @function verify
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_ClassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.create_on_client != null && message.hasOwnProperty("create_on_client"))
                if (typeof message.create_on_client !== "boolean")
                    return "create_on_client: boolean expected";
            if (message.classes != null && message.hasOwnProperty("classes")) {
                if (!Array.isArray(message.classes))
                    return "classes: array expected";
                for (var i = 0; i < message.classes.length; ++i) {
                    var error = $root.CSVCMsg_ClassInfo.class_t.verify(message.classes[i]);
                    if (error)
                        return "classes." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_ClassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
         */
        CSVCMsg_ClassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_ClassInfo)
                return object;
            var message = new $root.CSVCMsg_ClassInfo();
            if (object.create_on_client != null)
                message.create_on_client = Boolean(object.create_on_client);
            if (object.classes) {
                if (!Array.isArray(object.classes))
                    throw TypeError(".CSVCMsg_ClassInfo.classes: array expected");
                message.classes = [];
                for (var i = 0; i < object.classes.length; ++i) {
                    if (typeof object.classes[i] !== "object")
                        throw TypeError(".CSVCMsg_ClassInfo.classes: object expected");
                    message.classes[i] = $root.CSVCMsg_ClassInfo.class_t.fromObject(object.classes[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_ClassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_ClassInfo
         * @static
         * @param {CSVCMsg_ClassInfo} message CSVCMsg_ClassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_ClassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.classes = [];
            if (options.defaults)
                object.create_on_client = false;
            if (message.create_on_client != null && message.hasOwnProperty("create_on_client"))
                object.create_on_client = message.create_on_client;
            if (message.classes && message.classes.length) {
                object.classes = [];
                for (var j = 0; j < message.classes.length; ++j)
                    object.classes[j] = $root.CSVCMsg_ClassInfo.class_t.toObject(message.classes[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_ClassInfo to JSON.
         * @function toJSON
         * @memberof CSVCMsg_ClassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_ClassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_ClassInfo.class_t = (function() {
    
            /**
             * Properties of a class_t.
             * @memberof CSVCMsg_ClassInfo
             * @interface Iclass_t
             * @property {number|null} [class_id] class_t class_id
             * @property {string|null} [data_table_name] class_t data_table_name
             * @property {string|null} [class_name] class_t class_name
             */
    
            /**
             * Constructs a new class_t.
             * @memberof CSVCMsg_ClassInfo
             * @classdesc Represents a class_t.
             * @implements Iclass_t
             * @constructor
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             */
            function class_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * class_t class_id.
             * @member {number} class_id
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.class_id = 0;
    
            /**
             * class_t data_table_name.
             * @member {string} data_table_name
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.data_table_name = "";
    
            /**
             * class_t class_name.
             * @member {string} class_name
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             */
            class_t.prototype.class_name = "";
    
            /**
             * Creates a new class_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
             * @returns {CSVCMsg_ClassInfo.class_t} class_t instance
             */
            class_t.create = function create(properties) {
                return new class_t(properties);
            };
    
            /**
             * Encodes the specified class_t message. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.class_id != null && message.hasOwnProperty("class_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.class_id);
                if (message.data_table_name != null && message.hasOwnProperty("data_table_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data_table_name);
                if (message.class_name != null && message.hasOwnProperty("class_name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.class_name);
                return writer;
            };
    
            /**
             * Encodes the specified class_t message, length delimited. Does not implicitly {@link CSVCMsg_ClassInfo.class_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.Iclass_t} message class_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            class_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.class_id = reader.int32();
                        break;
                    case 2:
                        message.data_table_name = reader.string();
                        break;
                    case 3:
                        message.class_name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a class_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            class_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a class_t message.
             * @function verify
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            class_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.class_id != null && message.hasOwnProperty("class_id"))
                    if (!$util.isInteger(message.class_id))
                        return "class_id: integer expected";
                if (message.data_table_name != null && message.hasOwnProperty("data_table_name"))
                    if (!$util.isString(message.data_table_name))
                        return "data_table_name: string expected";
                if (message.class_name != null && message.hasOwnProperty("class_name"))
                    if (!$util.isString(message.class_name))
                        return "class_name: string expected";
                return null;
            };
    
            /**
             * Creates a class_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_ClassInfo.class_t} class_t
             */
            class_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_ClassInfo.class_t)
                    return object;
                var message = new $root.CSVCMsg_ClassInfo.class_t();
                if (object.class_id != null)
                    message.class_id = object.class_id | 0;
                if (object.data_table_name != null)
                    message.data_table_name = String(object.data_table_name);
                if (object.class_name != null)
                    message.class_name = String(object.class_name);
                return message;
            };
    
            /**
             * Creates a plain object from a class_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_ClassInfo.class_t
             * @static
             * @param {CSVCMsg_ClassInfo.class_t} message class_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            class_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.class_id = 0;
                    object.data_table_name = "";
                    object.class_name = "";
                }
                if (message.class_id != null && message.hasOwnProperty("class_id"))
                    object.class_id = message.class_id;
                if (message.data_table_name != null && message.hasOwnProperty("data_table_name"))
                    object.data_table_name = message.data_table_name;
                if (message.class_name != null && message.hasOwnProperty("class_name"))
                    object.class_name = message.class_name;
                return object;
            };
    
            /**
             * Converts this class_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_ClassInfo.class_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            class_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return class_t;
        })();
    
        return CSVCMsg_ClassInfo;
    })();
    
    $root.CSVCMsg_SendTable = (function() {
    
        /**
         * Properties of a CSVCMsg_SendTable.
         * @exports ICSVCMsg_SendTable
         * @interface ICSVCMsg_SendTable
         * @property {boolean|null} [is_end] CSVCMsg_SendTable is_end
         * @property {string|null} [net_table_name] CSVCMsg_SendTable net_table_name
         * @property {boolean|null} [needs_decoder] CSVCMsg_SendTable needs_decoder
         * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
         */
    
        /**
         * Constructs a new CSVCMsg_SendTable.
         * @exports CSVCMsg_SendTable
         * @classdesc Represents a CSVCMsg_SendTable.
         * @implements ICSVCMsg_SendTable
         * @constructor
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         */
        function CSVCMsg_SendTable(properties) {
            this.props = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SendTable is_end.
         * @member {boolean} is_end
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.is_end = false;
    
        /**
         * CSVCMsg_SendTable net_table_name.
         * @member {string} net_table_name
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.net_table_name = "";
    
        /**
         * CSVCMsg_SendTable needs_decoder.
         * @member {boolean} needs_decoder
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.needs_decoder = false;
    
        /**
         * CSVCMsg_SendTable props.
         * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
         * @memberof CSVCMsg_SendTable
         * @instance
         */
        CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_SendTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable=} [properties] Properties to set
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable instance
         */
        CSVCMsg_SendTable.create = function create(properties) {
            return new CSVCMsg_SendTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_end != null && message.hasOwnProperty("is_end"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.is_end);
            if (message.net_table_name != null && message.hasOwnProperty("net_table_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.net_table_name);
            if (message.needs_decoder != null && message.hasOwnProperty("needs_decoder"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.needs_decoder);
            if (message.props != null && message.props.length)
                for (var i = 0; i < message.props.length; ++i)
                    $root.CSVCMsg_SendTable.sendprop_t.encode(message.props[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SendTable message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {ICSVCMsg_SendTable} message CSVCMsg_SendTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SendTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_end = reader.bool();
                    break;
                case 2:
                    message.net_table_name = reader.string();
                    break;
                case 3:
                    message.needs_decoder = reader.bool();
                    break;
                case 4:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SendTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SendTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SendTable message.
         * @function verify
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SendTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_end != null && message.hasOwnProperty("is_end"))
                if (typeof message.is_end !== "boolean")
                    return "is_end: boolean expected";
            if (message.net_table_name != null && message.hasOwnProperty("net_table_name"))
                if (!$util.isString(message.net_table_name))
                    return "net_table_name: string expected";
            if (message.needs_decoder != null && message.hasOwnProperty("needs_decoder"))
                if (typeof message.needs_decoder !== "boolean")
                    return "needs_decoder: boolean expected";
            if (message.props != null && message.hasOwnProperty("props")) {
                if (!Array.isArray(message.props))
                    return "props: array expected";
                for (var i = 0; i < message.props.length; ++i) {
                    var error = $root.CSVCMsg_SendTable.sendprop_t.verify(message.props[i]);
                    if (error)
                        return "props." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SendTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
         */
        CSVCMsg_SendTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SendTable)
                return object;
            var message = new $root.CSVCMsg_SendTable();
            if (object.is_end != null)
                message.is_end = Boolean(object.is_end);
            if (object.net_table_name != null)
                message.net_table_name = String(object.net_table_name);
            if (object.needs_decoder != null)
                message.needs_decoder = Boolean(object.needs_decoder);
            if (object.props) {
                if (!Array.isArray(object.props))
                    throw TypeError(".CSVCMsg_SendTable.props: array expected");
                message.props = [];
                for (var i = 0; i < object.props.length; ++i) {
                    if (typeof object.props[i] !== "object")
                        throw TypeError(".CSVCMsg_SendTable.props: object expected");
                    message.props[i] = $root.CSVCMsg_SendTable.sendprop_t.fromObject(object.props[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SendTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SendTable
         * @static
         * @param {CSVCMsg_SendTable} message CSVCMsg_SendTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SendTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.props = [];
            if (options.defaults) {
                object.is_end = false;
                object.net_table_name = "";
                object.needs_decoder = false;
            }
            if (message.is_end != null && message.hasOwnProperty("is_end"))
                object.is_end = message.is_end;
            if (message.net_table_name != null && message.hasOwnProperty("net_table_name"))
                object.net_table_name = message.net_table_name;
            if (message.needs_decoder != null && message.hasOwnProperty("needs_decoder"))
                object.needs_decoder = message.needs_decoder;
            if (message.props && message.props.length) {
                object.props = [];
                for (var j = 0; j < message.props.length; ++j)
                    object.props[j] = $root.CSVCMsg_SendTable.sendprop_t.toObject(message.props[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SendTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SendTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SendTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_SendTable.sendprop_t = (function() {
    
            /**
             * Properties of a sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @interface Isendprop_t
             * @property {number|null} [type] sendprop_t type
             * @property {string|null} [var_name] sendprop_t var_name
             * @property {number|null} [flags] sendprop_t flags
             * @property {number|null} [priority] sendprop_t priority
             * @property {string|null} [dt_name] sendprop_t dt_name
             * @property {number|null} [num_elements] sendprop_t num_elements
             * @property {number|null} [low_value] sendprop_t low_value
             * @property {number|null} [high_value] sendprop_t high_value
             * @property {number|null} [num_bits] sendprop_t num_bits
             */
    
            /**
             * Constructs a new sendprop_t.
             * @memberof CSVCMsg_SendTable
             * @classdesc Represents a sendprop_t.
             * @implements Isendprop_t
             * @constructor
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             */
            function sendprop_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sendprop_t type.
             * @member {number} type
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.type = 0;
    
            /**
             * sendprop_t var_name.
             * @member {string} var_name
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.var_name = "";
    
            /**
             * sendprop_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.flags = 0;
    
            /**
             * sendprop_t priority.
             * @member {number} priority
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.priority = 0;
    
            /**
             * sendprop_t dt_name.
             * @member {string} dt_name
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.dt_name = "";
    
            /**
             * sendprop_t num_elements.
             * @member {number} num_elements
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.num_elements = 0;
    
            /**
             * sendprop_t low_value.
             * @member {number} low_value
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.low_value = 0;
    
            /**
             * sendprop_t high_value.
             * @member {number} high_value
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.high_value = 0;
    
            /**
             * sendprop_t num_bits.
             * @member {number} num_bits
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             */
            sendprop_t.prototype.num_bits = 0;
    
            /**
             * Creates a new sendprop_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t instance
             */
            sendprop_t.create = function create(properties) {
                return new sendprop_t(properties);
            };
    
            /**
             * Encodes the specified sendprop_t message. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.var_name != null && message.hasOwnProperty("var_name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.var_name);
                if (message.flags != null && message.hasOwnProperty("flags"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.flags);
                if (message.priority != null && message.hasOwnProperty("priority"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.priority);
                if (message.dt_name != null && message.hasOwnProperty("dt_name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.dt_name);
                if (message.num_elements != null && message.hasOwnProperty("num_elements"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.num_elements);
                if (message.low_value != null && message.hasOwnProperty("low_value"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.low_value);
                if (message.high_value != null && message.hasOwnProperty("high_value"))
                    writer.uint32(/* id 8, wireType 5 =*/69).float(message.high_value);
                if (message.num_bits != null && message.hasOwnProperty("num_bits"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.num_bits);
                return writer;
            };
    
            /**
             * Encodes the specified sendprop_t message, length delimited. Does not implicitly {@link CSVCMsg_SendTable.sendprop_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.Isendprop_t} message sendprop_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sendprop_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.var_name = reader.string();
                        break;
                    case 3:
                        message.flags = reader.int32();
                        break;
                    case 4:
                        message.priority = reader.int32();
                        break;
                    case 5:
                        message.dt_name = reader.string();
                        break;
                    case 6:
                        message.num_elements = reader.int32();
                        break;
                    case 7:
                        message.low_value = reader.float();
                        break;
                    case 8:
                        message.high_value = reader.float();
                        break;
                    case 9:
                        message.num_bits = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sendprop_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sendprop_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sendprop_t message.
             * @function verify
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sendprop_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.var_name != null && message.hasOwnProperty("var_name"))
                    if (!$util.isString(message.var_name))
                        return "var_name: string expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                if (message.dt_name != null && message.hasOwnProperty("dt_name"))
                    if (!$util.isString(message.dt_name))
                        return "dt_name: string expected";
                if (message.num_elements != null && message.hasOwnProperty("num_elements"))
                    if (!$util.isInteger(message.num_elements))
                        return "num_elements: integer expected";
                if (message.low_value != null && message.hasOwnProperty("low_value"))
                    if (typeof message.low_value !== "number")
                        return "low_value: number expected";
                if (message.high_value != null && message.hasOwnProperty("high_value"))
                    if (typeof message.high_value !== "number")
                        return "high_value: number expected";
                if (message.num_bits != null && message.hasOwnProperty("num_bits"))
                    if (!$util.isInteger(message.num_bits))
                        return "num_bits: integer expected";
                return null;
            };
    
            /**
             * Creates a sendprop_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
             */
            sendprop_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_SendTable.sendprop_t)
                    return object;
                var message = new $root.CSVCMsg_SendTable.sendprop_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.var_name != null)
                    message.var_name = String(object.var_name);
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.priority != null)
                    message.priority = object.priority | 0;
                if (object.dt_name != null)
                    message.dt_name = String(object.dt_name);
                if (object.num_elements != null)
                    message.num_elements = object.num_elements | 0;
                if (object.low_value != null)
                    message.low_value = Number(object.low_value);
                if (object.high_value != null)
                    message.high_value = Number(object.high_value);
                if (object.num_bits != null)
                    message.num_bits = object.num_bits | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a sendprop_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @static
             * @param {CSVCMsg_SendTable.sendprop_t} message sendprop_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sendprop_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.var_name = "";
                    object.flags = 0;
                    object.priority = 0;
                    object.dt_name = "";
                    object.num_elements = 0;
                    object.low_value = 0;
                    object.high_value = 0;
                    object.num_bits = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.var_name != null && message.hasOwnProperty("var_name"))
                    object.var_name = message.var_name;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                if (message.dt_name != null && message.hasOwnProperty("dt_name"))
                    object.dt_name = message.dt_name;
                if (message.num_elements != null && message.hasOwnProperty("num_elements"))
                    object.num_elements = message.num_elements;
                if (message.low_value != null && message.hasOwnProperty("low_value"))
                    object.low_value = options.json && !isFinite(message.low_value) ? String(message.low_value) : message.low_value;
                if (message.high_value != null && message.hasOwnProperty("high_value"))
                    object.high_value = options.json && !isFinite(message.high_value) ? String(message.high_value) : message.high_value;
                if (message.num_bits != null && message.hasOwnProperty("num_bits"))
                    object.num_bits = message.num_bits;
                return object;
            };
    
            /**
             * Converts this sendprop_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_SendTable.sendprop_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sendprop_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return sendprop_t;
        })();
    
        return CSVCMsg_SendTable;
    })();
    
    $root.CSVCMsg_Print = (function() {
    
        /**
         * Properties of a CSVCMsg_Print.
         * @exports ICSVCMsg_Print
         * @interface ICSVCMsg_Print
         * @property {string|null} [text] CSVCMsg_Print text
         */
    
        /**
         * Constructs a new CSVCMsg_Print.
         * @exports CSVCMsg_Print
         * @classdesc Represents a CSVCMsg_Print.
         * @implements ICSVCMsg_Print
         * @constructor
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         */
        function CSVCMsg_Print(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Print text.
         * @member {string} text
         * @memberof CSVCMsg_Print
         * @instance
         */
        CSVCMsg_Print.prototype.text = "";
    
        /**
         * Creates a new CSVCMsg_Print instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print=} [properties] Properties to set
         * @returns {CSVCMsg_Print} CSVCMsg_Print instance
         */
        CSVCMsg_Print.create = function create(properties) {
            return new CSVCMsg_Print(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && message.hasOwnProperty("text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Print message, length delimited. Does not implicitly {@link CSVCMsg_Print.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {ICSVCMsg_Print} message CSVCMsg_Print message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Print.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Print message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Print
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Print.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Print message.
         * @function verify
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Print.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Print message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Print} CSVCMsg_Print
         */
        CSVCMsg_Print.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Print)
                return object;
            var message = new $root.CSVCMsg_Print();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Print message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Print
         * @static
         * @param {CSVCMsg_Print} message CSVCMsg_Print
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Print.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Print to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Print
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Print.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Print;
    })();
    
    $root.CSVCMsg_SetPause = (function() {
    
        /**
         * Properties of a CSVCMsg_SetPause.
         * @exports ICSVCMsg_SetPause
         * @interface ICSVCMsg_SetPause
         * @property {boolean|null} [paused] CSVCMsg_SetPause paused
         */
    
        /**
         * Constructs a new CSVCMsg_SetPause.
         * @exports CSVCMsg_SetPause
         * @classdesc Represents a CSVCMsg_SetPause.
         * @implements ICSVCMsg_SetPause
         * @constructor
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         */
        function CSVCMsg_SetPause(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetPause paused.
         * @member {boolean} paused
         * @memberof CSVCMsg_SetPause
         * @instance
         */
        CSVCMsg_SetPause.prototype.paused = false;
    
        /**
         * Creates a new CSVCMsg_SetPause instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause=} [properties] Properties to set
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause instance
         */
        CSVCMsg_SetPause.create = function create(properties) {
            return new CSVCMsg_SetPause(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paused != null && message.hasOwnProperty("paused"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.paused);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetPause message, length delimited. Does not implicitly {@link CSVCMsg_SetPause.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {ICSVCMsg_SetPause} message CSVCMsg_SetPause message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetPause.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paused = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetPause message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetPause.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetPause message.
         * @function verify
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetPause.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paused != null && message.hasOwnProperty("paused"))
                if (typeof message.paused !== "boolean")
                    return "paused: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetPause message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
         */
        CSVCMsg_SetPause.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetPause)
                return object;
            var message = new $root.CSVCMsg_SetPause();
            if (object.paused != null)
                message.paused = Boolean(object.paused);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetPause message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetPause
         * @static
         * @param {CSVCMsg_SetPause} message CSVCMsg_SetPause
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetPause.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.paused = false;
            if (message.paused != null && message.hasOwnProperty("paused"))
                object.paused = message.paused;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetPause to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetPause
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetPause.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SetPause;
    })();
    
    $root.CSVCMsg_SetView = (function() {
    
        /**
         * Properties of a CSVCMsg_SetView.
         * @exports ICSVCMsg_SetView
         * @interface ICSVCMsg_SetView
         * @property {number|null} [entity_index] CSVCMsg_SetView entity_index
         */
    
        /**
         * Constructs a new CSVCMsg_SetView.
         * @exports CSVCMsg_SetView
         * @classdesc Represents a CSVCMsg_SetView.
         * @implements ICSVCMsg_SetView
         * @constructor
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         */
        function CSVCMsg_SetView(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SetView entity_index.
         * @member {number} entity_index
         * @memberof CSVCMsg_SetView
         * @instance
         */
        CSVCMsg_SetView.prototype.entity_index = 0;
    
        /**
         * Creates a new CSVCMsg_SetView instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView=} [properties] Properties to set
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView instance
         */
        CSVCMsg_SetView.create = function create(properties) {
            return new CSVCMsg_SetView(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.entity_index);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SetView message, length delimited. Does not implicitly {@link CSVCMsg_SetView.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {ICSVCMsg_SetView} message CSVCMsg_SetView message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SetView.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.entity_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SetView message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SetView
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SetView.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SetView message.
         * @function verify
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SetView.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SetView message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SetView} CSVCMsg_SetView
         */
        CSVCMsg_SetView.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SetView)
                return object;
            var message = new $root.CSVCMsg_SetView();
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SetView message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SetView
         * @static
         * @param {CSVCMsg_SetView} message CSVCMsg_SetView
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SetView.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entity_index = 0;
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SetView to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SetView
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SetView.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SetView;
    })();
    
    $root.CSVCMsg_CreateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_CreateStringTable.
         * @exports ICSVCMsg_CreateStringTable
         * @interface ICSVCMsg_CreateStringTable
         * @property {string|null} [name] CSVCMsg_CreateStringTable name
         * @property {number|null} [max_entries] CSVCMsg_CreateStringTable max_entries
         * @property {number|null} [num_entries] CSVCMsg_CreateStringTable num_entries
         * @property {boolean|null} [user_data_fixed_size] CSVCMsg_CreateStringTable user_data_fixed_size
         * @property {number|null} [user_data_size] CSVCMsg_CreateStringTable user_data_size
         * @property {number|null} [user_data_size_bits] CSVCMsg_CreateStringTable user_data_size_bits
         * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
         * @property {Uint8Array|null} [string_data] CSVCMsg_CreateStringTable string_data
         */
    
        /**
         * Constructs a new CSVCMsg_CreateStringTable.
         * @exports CSVCMsg_CreateStringTable
         * @classdesc Represents a CSVCMsg_CreateStringTable.
         * @implements ICSVCMsg_CreateStringTable
         * @constructor
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_CreateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CreateStringTable name.
         * @member {string} name
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.name = "";
    
        /**
         * CSVCMsg_CreateStringTable max_entries.
         * @member {number} max_entries
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.max_entries = 0;
    
        /**
         * CSVCMsg_CreateStringTable num_entries.
         * @member {number} num_entries
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.num_entries = 0;
    
        /**
         * CSVCMsg_CreateStringTable user_data_fixed_size.
         * @member {boolean} user_data_fixed_size
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_fixed_size = false;
    
        /**
         * CSVCMsg_CreateStringTable user_data_size.
         * @member {number} user_data_size
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_size = 0;
    
        /**
         * CSVCMsg_CreateStringTable user_data_size_bits.
         * @member {number} user_data_size_bits
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.user_data_size_bits = 0;
    
        /**
         * CSVCMsg_CreateStringTable flags.
         * @member {number} flags
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.flags = 0;
    
        /**
         * CSVCMsg_CreateStringTable string_data.
         * @member {Uint8Array} string_data
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         */
        CSVCMsg_CreateStringTable.prototype.string_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_CreateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable instance
         */
        CSVCMsg_CreateStringTable.create = function create(properties) {
            return new CSVCMsg_CreateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.max_entries);
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num_entries);
            if (message.user_data_fixed_size != null && message.hasOwnProperty("user_data_fixed_size"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.user_data_fixed_size);
            if (message.user_data_size != null && message.hasOwnProperty("user_data_size"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.user_data_size);
            if (message.user_data_size_bits != null && message.hasOwnProperty("user_data_size_bits"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.user_data_size_bits);
            if (message.flags != null && message.hasOwnProperty("flags"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.flags);
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.string_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CreateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_CreateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {ICSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CreateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.max_entries = reader.int32();
                    break;
                case 3:
                    message.num_entries = reader.int32();
                    break;
                case 4:
                    message.user_data_fixed_size = reader.bool();
                    break;
                case 5:
                    message.user_data_size = reader.int32();
                    break;
                case 6:
                    message.user_data_size_bits = reader.int32();
                    break;
                case 7:
                    message.flags = reader.int32();
                    break;
                case 8:
                    message.string_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CreateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CreateStringTable message.
         * @function verify
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CreateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                if (!$util.isInteger(message.max_entries))
                    return "max_entries: integer expected";
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                if (!$util.isInteger(message.num_entries))
                    return "num_entries: integer expected";
            if (message.user_data_fixed_size != null && message.hasOwnProperty("user_data_fixed_size"))
                if (typeof message.user_data_fixed_size !== "boolean")
                    return "user_data_fixed_size: boolean expected";
            if (message.user_data_size != null && message.hasOwnProperty("user_data_size"))
                if (!$util.isInteger(message.user_data_size))
                    return "user_data_size: integer expected";
            if (message.user_data_size_bits != null && message.hasOwnProperty("user_data_size_bits"))
                if (!$util.isInteger(message.user_data_size_bits))
                    return "user_data_size_bits: integer expected";
            if (message.flags != null && message.hasOwnProperty("flags"))
                if (!$util.isInteger(message.flags))
                    return "flags: integer expected";
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                if (!(message.string_data && typeof message.string_data.length === "number" || $util.isString(message.string_data)))
                    return "string_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CreateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
         */
        CSVCMsg_CreateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CreateStringTable)
                return object;
            var message = new $root.CSVCMsg_CreateStringTable();
            if (object.name != null)
                message.name = String(object.name);
            if (object.max_entries != null)
                message.max_entries = object.max_entries | 0;
            if (object.num_entries != null)
                message.num_entries = object.num_entries | 0;
            if (object.user_data_fixed_size != null)
                message.user_data_fixed_size = Boolean(object.user_data_fixed_size);
            if (object.user_data_size != null)
                message.user_data_size = object.user_data_size | 0;
            if (object.user_data_size_bits != null)
                message.user_data_size_bits = object.user_data_size_bits | 0;
            if (object.flags != null)
                message.flags = object.flags | 0;
            if (object.string_data != null)
                if (typeof object.string_data === "string")
                    $util.base64.decode(object.string_data, message.string_data = $util.newBuffer($util.base64.length(object.string_data)), 0);
                else if (object.string_data.length)
                    message.string_data = object.string_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CreateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CreateStringTable
         * @static
         * @param {CSVCMsg_CreateStringTable} message CSVCMsg_CreateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CreateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.max_entries = 0;
                object.num_entries = 0;
                object.user_data_fixed_size = false;
                object.user_data_size = 0;
                object.user_data_size_bits = 0;
                object.flags = 0;
                if (options.bytes === String)
                    object.string_data = "";
                else {
                    object.string_data = [];
                    if (options.bytes !== Array)
                        object.string_data = $util.newBuffer(object.string_data);
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                object.max_entries = message.max_entries;
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                object.num_entries = message.num_entries;
            if (message.user_data_fixed_size != null && message.hasOwnProperty("user_data_fixed_size"))
                object.user_data_fixed_size = message.user_data_fixed_size;
            if (message.user_data_size != null && message.hasOwnProperty("user_data_size"))
                object.user_data_size = message.user_data_size;
            if (message.user_data_size_bits != null && message.hasOwnProperty("user_data_size_bits"))
                object.user_data_size_bits = message.user_data_size_bits;
            if (message.flags != null && message.hasOwnProperty("flags"))
                object.flags = message.flags;
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                object.string_data = options.bytes === String ? $util.base64.encode(message.string_data, 0, message.string_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_data) : message.string_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CreateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CreateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CreateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CreateStringTable;
    })();
    
    $root.CSVCMsg_UpdateStringTable = (function() {
    
        /**
         * Properties of a CSVCMsg_UpdateStringTable.
         * @exports ICSVCMsg_UpdateStringTable
         * @interface ICSVCMsg_UpdateStringTable
         * @property {number|null} [table_id] CSVCMsg_UpdateStringTable table_id
         * @property {number|null} [num_changed_entries] CSVCMsg_UpdateStringTable num_changed_entries
         * @property {Uint8Array|null} [string_data] CSVCMsg_UpdateStringTable string_data
         */
    
        /**
         * Constructs a new CSVCMsg_UpdateStringTable.
         * @exports CSVCMsg_UpdateStringTable
         * @classdesc Represents a CSVCMsg_UpdateStringTable.
         * @implements ICSVCMsg_UpdateStringTable
         * @constructor
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         */
        function CSVCMsg_UpdateStringTable(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UpdateStringTable table_id.
         * @member {number} table_id
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.table_id = 0;
    
        /**
         * CSVCMsg_UpdateStringTable num_changed_entries.
         * @member {number} num_changed_entries
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.num_changed_entries = 0;
    
        /**
         * CSVCMsg_UpdateStringTable string_data.
         * @member {Uint8Array} string_data
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         */
        CSVCMsg_UpdateStringTable.prototype.string_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_UpdateStringTable instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable instance
         */
        CSVCMsg_UpdateStringTable.create = function create(properties) {
            return new CSVCMsg_UpdateStringTable(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table_id != null && message.hasOwnProperty("table_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.table_id);
            if (message.num_changed_entries != null && message.hasOwnProperty("num_changed_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num_changed_entries);
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.string_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UpdateStringTable message, length delimited. Does not implicitly {@link CSVCMsg_UpdateStringTable.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {ICSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UpdateStringTable.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.table_id = reader.int32();
                    break;
                case 2:
                    message.num_changed_entries = reader.int32();
                    break;
                case 3:
                    message.string_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UpdateStringTable.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UpdateStringTable message.
         * @function verify
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UpdateStringTable.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.table_id != null && message.hasOwnProperty("table_id"))
                if (!$util.isInteger(message.table_id))
                    return "table_id: integer expected";
            if (message.num_changed_entries != null && message.hasOwnProperty("num_changed_entries"))
                if (!$util.isInteger(message.num_changed_entries))
                    return "num_changed_entries: integer expected";
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                if (!(message.string_data && typeof message.string_data.length === "number" || $util.isString(message.string_data)))
                    return "string_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UpdateStringTable message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
         */
        CSVCMsg_UpdateStringTable.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UpdateStringTable)
                return object;
            var message = new $root.CSVCMsg_UpdateStringTable();
            if (object.table_id != null)
                message.table_id = object.table_id | 0;
            if (object.num_changed_entries != null)
                message.num_changed_entries = object.num_changed_entries | 0;
            if (object.string_data != null)
                if (typeof object.string_data === "string")
                    $util.base64.decode(object.string_data, message.string_data = $util.newBuffer($util.base64.length(object.string_data)), 0);
                else if (object.string_data.length)
                    message.string_data = object.string_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UpdateStringTable message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UpdateStringTable
         * @static
         * @param {CSVCMsg_UpdateStringTable} message CSVCMsg_UpdateStringTable
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UpdateStringTable.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.table_id = 0;
                object.num_changed_entries = 0;
                if (options.bytes === String)
                    object.string_data = "";
                else {
                    object.string_data = [];
                    if (options.bytes !== Array)
                        object.string_data = $util.newBuffer(object.string_data);
                }
            }
            if (message.table_id != null && message.hasOwnProperty("table_id"))
                object.table_id = message.table_id;
            if (message.num_changed_entries != null && message.hasOwnProperty("num_changed_entries"))
                object.num_changed_entries = message.num_changed_entries;
            if (message.string_data != null && message.hasOwnProperty("string_data"))
                object.string_data = options.bytes === String ? $util.base64.encode(message.string_data, 0, message.string_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_data) : message.string_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UpdateStringTable to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UpdateStringTable
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UpdateStringTable.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UpdateStringTable;
    })();
    
    $root.CSVCMsg_VoiceInit = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceInit.
         * @exports ICSVCMsg_VoiceInit
         * @interface ICSVCMsg_VoiceInit
         * @property {number|null} [quality] CSVCMsg_VoiceInit quality
         * @property {string|null} [codec] CSVCMsg_VoiceInit codec
         * @property {number|null} [version] CSVCMsg_VoiceInit version
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceInit.
         * @exports CSVCMsg_VoiceInit
         * @classdesc Represents a CSVCMsg_VoiceInit.
         * @implements ICSVCMsg_VoiceInit
         * @constructor
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         */
        function CSVCMsg_VoiceInit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceInit quality.
         * @member {number} quality
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.quality = 0;
    
        /**
         * CSVCMsg_VoiceInit codec.
         * @member {string} codec
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.codec = "";
    
        /**
         * CSVCMsg_VoiceInit version.
         * @member {number} version
         * @memberof CSVCMsg_VoiceInit
         * @instance
         */
        CSVCMsg_VoiceInit.prototype.version = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceInit instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit instance
         */
        CSVCMsg_VoiceInit.create = function create(properties) {
            return new CSVCMsg_VoiceInit(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quality != null && message.hasOwnProperty("quality"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.quality);
            if (message.codec != null && message.hasOwnProperty("codec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.codec);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceInit message, length delimited. Does not implicitly {@link CSVCMsg_VoiceInit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {ICSVCMsg_VoiceInit} message CSVCMsg_VoiceInit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceInit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.codec = reader.string();
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceInit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceInit message.
         * @function verify
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceInit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.quality != null && message.hasOwnProperty("quality"))
                if (!$util.isInteger(message.quality))
                    return "quality: integer expected";
            if (message.codec != null && message.hasOwnProperty("codec"))
                if (!$util.isString(message.codec))
                    return "codec: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceInit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
         */
        CSVCMsg_VoiceInit.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceInit)
                return object;
            var message = new $root.CSVCMsg_VoiceInit();
            if (object.quality != null)
                message.quality = object.quality | 0;
            if (object.codec != null)
                message.codec = String(object.codec);
            if (object.version != null)
                message.version = object.version | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceInit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceInit
         * @static
         * @param {CSVCMsg_VoiceInit} message CSVCMsg_VoiceInit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceInit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.quality = 0;
                object.codec = "";
                object.version = 0;
            }
            if (message.quality != null && message.hasOwnProperty("quality"))
                object.quality = message.quality;
            if (message.codec != null && message.hasOwnProperty("codec"))
                object.codec = message.codec;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceInit to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceInit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceInit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_VoiceInit;
    })();
    
    $root.CSVCMsg_VoiceData = (function() {
    
        /**
         * Properties of a CSVCMsg_VoiceData.
         * @exports ICSVCMsg_VoiceData
         * @interface ICSVCMsg_VoiceData
         * @property {number|null} [client] CSVCMsg_VoiceData client
         * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
         * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
         * @property {number|null} [audible_mask] CSVCMsg_VoiceData audible_mask
         * @property {Uint8Array|null} [voice_data] CSVCMsg_VoiceData voice_data
         * @property {boolean|null} [caster] CSVCMsg_VoiceData caster
         * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format
         * @property {number|null} [sequence_bytes] CSVCMsg_VoiceData sequence_bytes
         * @property {number|null} [section_number] CSVCMsg_VoiceData section_number
         * @property {number|null} [uncompressed_sample_offset] CSVCMsg_VoiceData uncompressed_sample_offset
         */
    
        /**
         * Constructs a new CSVCMsg_VoiceData.
         * @exports CSVCMsg_VoiceData
         * @classdesc Represents a CSVCMsg_VoiceData.
         * @implements ICSVCMsg_VoiceData
         * @constructor
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         */
        function CSVCMsg_VoiceData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_VoiceData client.
         * @member {number} client
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.client = 0;
    
        /**
         * CSVCMsg_VoiceData proximity.
         * @member {boolean} proximity
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.proximity = false;
    
        /**
         * CSVCMsg_VoiceData xuid.
         * @member {number|Long} xuid
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * CSVCMsg_VoiceData audible_mask.
         * @member {number} audible_mask
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.audible_mask = 0;
    
        /**
         * CSVCMsg_VoiceData voice_data.
         * @member {Uint8Array} voice_data
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.voice_data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_VoiceData caster.
         * @member {boolean} caster
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.caster = false;
    
        /**
         * CSVCMsg_VoiceData format.
         * @member {VoiceDataFormat_t} format
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.format = 1;
    
        /**
         * CSVCMsg_VoiceData sequence_bytes.
         * @member {number} sequence_bytes
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.sequence_bytes = 0;
    
        /**
         * CSVCMsg_VoiceData section_number.
         * @member {number} section_number
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.section_number = 0;
    
        /**
         * CSVCMsg_VoiceData uncompressed_sample_offset.
         * @member {number} uncompressed_sample_offset
         * @memberof CSVCMsg_VoiceData
         * @instance
         */
        CSVCMsg_VoiceData.prototype.uncompressed_sample_offset = 0;
    
        /**
         * Creates a new CSVCMsg_VoiceData instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData instance
         */
        CSVCMsg_VoiceData.create = function create(properties) {
            return new CSVCMsg_VoiceData(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.client != null && message.hasOwnProperty("client"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.client);
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.proximity);
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.xuid);
            if (message.audible_mask != null && message.hasOwnProperty("audible_mask"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.audible_mask);
            if (message.voice_data != null && message.hasOwnProperty("voice_data"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.voice_data);
            if (message.caster != null && message.hasOwnProperty("caster"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.caster);
            if (message.format != null && message.hasOwnProperty("format"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.format);
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.sequence_bytes);
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.section_number);
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.uncompressed_sample_offset);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_VoiceData message, length delimited. Does not implicitly {@link CSVCMsg_VoiceData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {ICSVCMsg_VoiceData} message CSVCMsg_VoiceData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.client = reader.int32();
                    break;
                case 2:
                    message.proximity = reader.bool();
                    break;
                case 3:
                    message.xuid = reader.fixed64();
                    break;
                case 4:
                    message.audible_mask = reader.int32();
                    break;
                case 5:
                    message.voice_data = reader.bytes();
                    break;
                case 6:
                    message.caster = reader.bool();
                    break;
                case 7:
                    message.format = reader.int32();
                    break;
                case 8:
                    message.sequence_bytes = reader.int32();
                    break;
                case 9:
                    message.section_number = reader.uint32();
                    break;
                case 10:
                    message.uncompressed_sample_offset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_VoiceData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_VoiceData message.
         * @function verify
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_VoiceData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.client != null && message.hasOwnProperty("client"))
                if (!$util.isInteger(message.client))
                    return "client: integer expected";
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                if (typeof message.proximity !== "boolean")
                    return "proximity: boolean expected";
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (!$util.isInteger(message.xuid) && !(message.xuid && $util.isInteger(message.xuid.low) && $util.isInteger(message.xuid.high)))
                    return "xuid: integer|Long expected";
            if (message.audible_mask != null && message.hasOwnProperty("audible_mask"))
                if (!$util.isInteger(message.audible_mask))
                    return "audible_mask: integer expected";
            if (message.voice_data != null && message.hasOwnProperty("voice_data"))
                if (!(message.voice_data && typeof message.voice_data.length === "number" || $util.isString(message.voice_data)))
                    return "voice_data: buffer expected";
            if (message.caster != null && message.hasOwnProperty("caster"))
                if (typeof message.caster !== "boolean")
                    return "caster: boolean expected";
            if (message.format != null && message.hasOwnProperty("format"))
                switch (message.format) {
                default:
                    return "format: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                if (!$util.isInteger(message.sequence_bytes))
                    return "sequence_bytes: integer expected";
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                if (!$util.isInteger(message.section_number))
                    return "section_number: integer expected";
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                if (!$util.isInteger(message.uncompressed_sample_offset))
                    return "uncompressed_sample_offset: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_VoiceData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
         */
        CSVCMsg_VoiceData.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_VoiceData)
                return object;
            var message = new $root.CSVCMsg_VoiceData();
            if (object.client != null)
                message.client = object.client | 0;
            if (object.proximity != null)
                message.proximity = Boolean(object.proximity);
            if (object.xuid != null)
                if ($util.Long)
                    (message.xuid = $util.Long.fromValue(object.xuid)).unsigned = false;
                else if (typeof object.xuid === "string")
                    message.xuid = parseInt(object.xuid, 10);
                else if (typeof object.xuid === "number")
                    message.xuid = object.xuid;
                else if (typeof object.xuid === "object")
                    message.xuid = new $util.LongBits(object.xuid.low >>> 0, object.xuid.high >>> 0).toNumber();
            if (object.audible_mask != null)
                message.audible_mask = object.audible_mask | 0;
            if (object.voice_data != null)
                if (typeof object.voice_data === "string")
                    $util.base64.decode(object.voice_data, message.voice_data = $util.newBuffer($util.base64.length(object.voice_data)), 0);
                else if (object.voice_data.length)
                    message.voice_data = object.voice_data;
            if (object.caster != null)
                message.caster = Boolean(object.caster);
            switch (object.format) {
            case "VOICEDATA_FORMAT_STEAM":
            case 0:
                message.format = 0;
                break;
            case "VOICEDATA_FORMAT_ENGINE":
            case 1:
                message.format = 1;
                break;
            }
            if (object.sequence_bytes != null)
                message.sequence_bytes = object.sequence_bytes | 0;
            if (object.section_number != null)
                message.section_number = object.section_number >>> 0;
            if (object.uncompressed_sample_offset != null)
                message.uncompressed_sample_offset = object.uncompressed_sample_offset >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_VoiceData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_VoiceData
         * @static
         * @param {CSVCMsg_VoiceData} message CSVCMsg_VoiceData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_VoiceData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.client = 0;
                object.proximity = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.xuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.xuid = options.longs === String ? "0" : 0;
                object.audible_mask = 0;
                if (options.bytes === String)
                    object.voice_data = "";
                else {
                    object.voice_data = [];
                    if (options.bytes !== Array)
                        object.voice_data = $util.newBuffer(object.voice_data);
                }
                object.caster = false;
                object.format = options.enums === String ? "VOICEDATA_FORMAT_ENGINE" : 1;
                object.sequence_bytes = 0;
                object.section_number = 0;
                object.uncompressed_sample_offset = 0;
            }
            if (message.client != null && message.hasOwnProperty("client"))
                object.client = message.client;
            if (message.proximity != null && message.hasOwnProperty("proximity"))
                object.proximity = message.proximity;
            if (message.xuid != null && message.hasOwnProperty("xuid"))
                if (typeof message.xuid === "number")
                    object.xuid = options.longs === String ? String(message.xuid) : message.xuid;
                else
                    object.xuid = options.longs === String ? $util.Long.prototype.toString.call(message.xuid) : options.longs === Number ? new $util.LongBits(message.xuid.low >>> 0, message.xuid.high >>> 0).toNumber() : message.xuid;
            if (message.audible_mask != null && message.hasOwnProperty("audible_mask"))
                object.audible_mask = message.audible_mask;
            if (message.voice_data != null && message.hasOwnProperty("voice_data"))
                object.voice_data = options.bytes === String ? $util.base64.encode(message.voice_data, 0, message.voice_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.voice_data) : message.voice_data;
            if (message.caster != null && message.hasOwnProperty("caster"))
                object.caster = message.caster;
            if (message.format != null && message.hasOwnProperty("format"))
                object.format = options.enums === String ? $root.VoiceDataFormat_t[message.format] : message.format;
            if (message.sequence_bytes != null && message.hasOwnProperty("sequence_bytes"))
                object.sequence_bytes = message.sequence_bytes;
            if (message.section_number != null && message.hasOwnProperty("section_number"))
                object.section_number = message.section_number;
            if (message.uncompressed_sample_offset != null && message.hasOwnProperty("uncompressed_sample_offset"))
                object.uncompressed_sample_offset = message.uncompressed_sample_offset;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_VoiceData to JSON.
         * @function toJSON
         * @memberof CSVCMsg_VoiceData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_VoiceData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_VoiceData;
    })();
    
    $root.CSVCMsg_FixAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_FixAngle.
         * @exports ICSVCMsg_FixAngle
         * @interface ICSVCMsg_FixAngle
         * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_FixAngle.
         * @exports CSVCMsg_FixAngle
         * @classdesc Represents a CSVCMsg_FixAngle.
         * @implements ICSVCMsg_FixAngle
         * @constructor
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         */
        function CSVCMsg_FixAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_FixAngle relative.
         * @member {boolean} relative
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.relative = false;
    
        /**
         * CSVCMsg_FixAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_FixAngle
         * @instance
         */
        CSVCMsg_FixAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_FixAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle instance
         */
        CSVCMsg_FixAngle.create = function create(properties) {
            return new CSVCMsg_FixAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.relative != null && message.hasOwnProperty("relative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.relative);
            if (message.angle != null && message.hasOwnProperty("angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_FixAngle message, length delimited. Does not implicitly {@link CSVCMsg_FixAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {ICSVCMsg_FixAngle} message CSVCMsg_FixAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_FixAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_FixAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_FixAngle message.
         * @function verify
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_FixAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.relative != null && message.hasOwnProperty("relative"))
                if (typeof message.relative !== "boolean")
                    return "relative: boolean expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_FixAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
         */
        CSVCMsg_FixAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_FixAngle)
                return object;
            var message = new $root.CSVCMsg_FixAngle();
            if (object.relative != null)
                message.relative = Boolean(object.relative);
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_FixAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_FixAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_FixAngle
         * @static
         * @param {CSVCMsg_FixAngle} message CSVCMsg_FixAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_FixAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.relative = false;
                object.angle = null;
            }
            if (message.relative != null && message.hasOwnProperty("relative"))
                object.relative = message.relative;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_FixAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_FixAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_FixAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_FixAngle;
    })();
    
    $root.CSVCMsg_CrosshairAngle = (function() {
    
        /**
         * Properties of a CSVCMsg_CrosshairAngle.
         * @exports ICSVCMsg_CrosshairAngle
         * @interface ICSVCMsg_CrosshairAngle
         * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
         */
    
        /**
         * Constructs a new CSVCMsg_CrosshairAngle.
         * @exports CSVCMsg_CrosshairAngle
         * @classdesc Represents a CSVCMsg_CrosshairAngle.
         * @implements ICSVCMsg_CrosshairAngle
         * @constructor
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         */
        function CSVCMsg_CrosshairAngle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CrosshairAngle angle.
         * @member {ICMsgQAngle|null|undefined} angle
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         */
        CSVCMsg_CrosshairAngle.prototype.angle = null;
    
        /**
         * Creates a new CSVCMsg_CrosshairAngle instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle instance
         */
        CSVCMsg_CrosshairAngle.create = function create(properties) {
            return new CSVCMsg_CrosshairAngle(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.angle != null && message.hasOwnProperty("angle"))
                $root.CMsgQAngle.encode(message.angle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CrosshairAngle message, length delimited. Does not implicitly {@link CSVCMsg_CrosshairAngle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {ICSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CrosshairAngle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CrosshairAngle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CrosshairAngle message.
         * @function verify
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CrosshairAngle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.angle != null && message.hasOwnProperty("angle")) {
                var error = $root.CMsgQAngle.verify(message.angle);
                if (error)
                    return "angle." + error;
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CrosshairAngle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
         */
        CSVCMsg_CrosshairAngle.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CrosshairAngle)
                return object;
            var message = new $root.CSVCMsg_CrosshairAngle();
            if (object.angle != null) {
                if (typeof object.angle !== "object")
                    throw TypeError(".CSVCMsg_CrosshairAngle.angle: object expected");
                message.angle = $root.CMsgQAngle.fromObject(object.angle);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CrosshairAngle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CrosshairAngle
         * @static
         * @param {CSVCMsg_CrosshairAngle} message CSVCMsg_CrosshairAngle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CrosshairAngle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.angle = null;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = $root.CMsgQAngle.toObject(message.angle, options);
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CrosshairAngle to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CrosshairAngle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CrosshairAngle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CrosshairAngle;
    })();
    
    $root.CSVCMsg_Prefetch = (function() {
    
        /**
         * Properties of a CSVCMsg_Prefetch.
         * @exports ICSVCMsg_Prefetch
         * @interface ICSVCMsg_Prefetch
         * @property {number|null} [sound_index] CSVCMsg_Prefetch sound_index
         */
    
        /**
         * Constructs a new CSVCMsg_Prefetch.
         * @exports CSVCMsg_Prefetch
         * @classdesc Represents a CSVCMsg_Prefetch.
         * @implements ICSVCMsg_Prefetch
         * @constructor
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         */
        function CSVCMsg_Prefetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Prefetch sound_index.
         * @member {number} sound_index
         * @memberof CSVCMsg_Prefetch
         * @instance
         */
        CSVCMsg_Prefetch.prototype.sound_index = 0;
    
        /**
         * Creates a new CSVCMsg_Prefetch instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch instance
         */
        CSVCMsg_Prefetch.create = function create(properties) {
            return new CSVCMsg_Prefetch(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sound_index != null && message.hasOwnProperty("sound_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sound_index);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Prefetch message, length delimited. Does not implicitly {@link CSVCMsg_Prefetch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {ICSVCMsg_Prefetch} message CSVCMsg_Prefetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Prefetch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sound_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Prefetch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Prefetch message.
         * @function verify
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Prefetch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sound_index != null && message.hasOwnProperty("sound_index"))
                if (!$util.isInteger(message.sound_index))
                    return "sound_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Prefetch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
         */
        CSVCMsg_Prefetch.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Prefetch)
                return object;
            var message = new $root.CSVCMsg_Prefetch();
            if (object.sound_index != null)
                message.sound_index = object.sound_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Prefetch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Prefetch
         * @static
         * @param {CSVCMsg_Prefetch} message CSVCMsg_Prefetch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Prefetch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sound_index = 0;
            if (message.sound_index != null && message.hasOwnProperty("sound_index"))
                object.sound_index = message.sound_index;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Prefetch to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Prefetch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Prefetch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Prefetch;
    })();
    
    $root.CSVCMsg_BSPDecal = (function() {
    
        /**
         * Properties of a CSVCMsg_BSPDecal.
         * @exports ICSVCMsg_BSPDecal
         * @interface ICSVCMsg_BSPDecal
         * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
         * @property {number|null} [decal_texture_index] CSVCMsg_BSPDecal decal_texture_index
         * @property {number|null} [entity_index] CSVCMsg_BSPDecal entity_index
         * @property {number|null} [model_index] CSVCMsg_BSPDecal model_index
         * @property {boolean|null} [low_priority] CSVCMsg_BSPDecal low_priority
         */
    
        /**
         * Constructs a new CSVCMsg_BSPDecal.
         * @exports CSVCMsg_BSPDecal
         * @classdesc Represents a CSVCMsg_BSPDecal.
         * @implements ICSVCMsg_BSPDecal
         * @constructor
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         */
        function CSVCMsg_BSPDecal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_BSPDecal pos.
         * @member {ICMsgVector|null|undefined} pos
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.pos = null;
    
        /**
         * CSVCMsg_BSPDecal decal_texture_index.
         * @member {number} decal_texture_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.decal_texture_index = 0;
    
        /**
         * CSVCMsg_BSPDecal entity_index.
         * @member {number} entity_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.entity_index = 0;
    
        /**
         * CSVCMsg_BSPDecal model_index.
         * @member {number} model_index
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.model_index = 0;
    
        /**
         * CSVCMsg_BSPDecal low_priority.
         * @member {boolean} low_priority
         * @memberof CSVCMsg_BSPDecal
         * @instance
         */
        CSVCMsg_BSPDecal.prototype.low_priority = false;
    
        /**
         * Creates a new CSVCMsg_BSPDecal instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal instance
         */
        CSVCMsg_BSPDecal.create = function create(properties) {
            return new CSVCMsg_BSPDecal(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && message.hasOwnProperty("pos"))
                $root.CMsgVector.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.decal_texture_index != null && message.hasOwnProperty("decal_texture_index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decal_texture_index);
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.entity_index);
            if (message.model_index != null && message.hasOwnProperty("model_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.model_index);
            if (message.low_priority != null && message.hasOwnProperty("low_priority"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.low_priority);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_BSPDecal message, length delimited. Does not implicitly {@link CSVCMsg_BSPDecal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {ICSVCMsg_BSPDecal} message CSVCMsg_BSPDecal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_BSPDecal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.decal_texture_index = reader.int32();
                    break;
                case 3:
                    message.entity_index = reader.int32();
                    break;
                case 4:
                    message.model_index = reader.int32();
                    break;
                case 5:
                    message.low_priority = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_BSPDecal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_BSPDecal message.
         * @function verify
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_BSPDecal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.CMsgVector.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.decal_texture_index != null && message.hasOwnProperty("decal_texture_index"))
                if (!$util.isInteger(message.decal_texture_index))
                    return "decal_texture_index: integer expected";
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                if (!$util.isInteger(message.entity_index))
                    return "entity_index: integer expected";
            if (message.model_index != null && message.hasOwnProperty("model_index"))
                if (!$util.isInteger(message.model_index))
                    return "model_index: integer expected";
            if (message.low_priority != null && message.hasOwnProperty("low_priority"))
                if (typeof message.low_priority !== "boolean")
                    return "low_priority: boolean expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_BSPDecal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
         */
        CSVCMsg_BSPDecal.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_BSPDecal)
                return object;
            var message = new $root.CSVCMsg_BSPDecal();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".CSVCMsg_BSPDecal.pos: object expected");
                message.pos = $root.CMsgVector.fromObject(object.pos);
            }
            if (object.decal_texture_index != null)
                message.decal_texture_index = object.decal_texture_index | 0;
            if (object.entity_index != null)
                message.entity_index = object.entity_index | 0;
            if (object.model_index != null)
                message.model_index = object.model_index | 0;
            if (object.low_priority != null)
                message.low_priority = Boolean(object.low_priority);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_BSPDecal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_BSPDecal
         * @static
         * @param {CSVCMsg_BSPDecal} message CSVCMsg_BSPDecal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_BSPDecal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.decal_texture_index = 0;
                object.entity_index = 0;
                object.model_index = 0;
                object.low_priority = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.CMsgVector.toObject(message.pos, options);
            if (message.decal_texture_index != null && message.hasOwnProperty("decal_texture_index"))
                object.decal_texture_index = message.decal_texture_index;
            if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                object.entity_index = message.entity_index;
            if (message.model_index != null && message.hasOwnProperty("model_index"))
                object.model_index = message.model_index;
            if (message.low_priority != null && message.hasOwnProperty("low_priority"))
                object.low_priority = message.low_priority;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_BSPDecal to JSON.
         * @function toJSON
         * @memberof CSVCMsg_BSPDecal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_BSPDecal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_BSPDecal;
    })();
    
    $root.CSVCMsg_SplitScreen = (function() {
    
        /**
         * Properties of a CSVCMsg_SplitScreen.
         * @exports ICSVCMsg_SplitScreen
         * @interface ICSVCMsg_SplitScreen
         * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
         * @property {number|null} [slot] CSVCMsg_SplitScreen slot
         * @property {number|null} [player_index] CSVCMsg_SplitScreen player_index
         */
    
        /**
         * Constructs a new CSVCMsg_SplitScreen.
         * @exports CSVCMsg_SplitScreen
         * @classdesc Represents a CSVCMsg_SplitScreen.
         * @implements ICSVCMsg_SplitScreen
         * @constructor
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         */
        function CSVCMsg_SplitScreen(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_SplitScreen type.
         * @member {ESplitScreenMessageType} type
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.type = 0;
    
        /**
         * CSVCMsg_SplitScreen slot.
         * @member {number} slot
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.slot = 0;
    
        /**
         * CSVCMsg_SplitScreen player_index.
         * @member {number} player_index
         * @memberof CSVCMsg_SplitScreen
         * @instance
         */
        CSVCMsg_SplitScreen.prototype.player_index = 0;
    
        /**
         * Creates a new CSVCMsg_SplitScreen instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen instance
         */
        CSVCMsg_SplitScreen.create = function create(properties) {
            return new CSVCMsg_SplitScreen(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.slot != null && message.hasOwnProperty("slot"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.slot);
            if (message.player_index != null && message.hasOwnProperty("player_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.player_index);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_SplitScreen message, length delimited. Does not implicitly {@link CSVCMsg_SplitScreen.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {ICSVCMsg_SplitScreen} message CSVCMsg_SplitScreen message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_SplitScreen.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                case 3:
                    message.player_index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_SplitScreen.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_SplitScreen message.
         * @function verify
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_SplitScreen.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 1:
                    break;
                }
            if (message.slot != null && message.hasOwnProperty("slot"))
                if (!$util.isInteger(message.slot))
                    return "slot: integer expected";
            if (message.player_index != null && message.hasOwnProperty("player_index"))
                if (!$util.isInteger(message.player_index))
                    return "player_index: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_SplitScreen message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
         */
        CSVCMsg_SplitScreen.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_SplitScreen)
                return object;
            var message = new $root.CSVCMsg_SplitScreen();
            switch (object.type) {
            case "MSG_SPLITSCREEN_ADDUSER":
            case 0:
                message.type = 0;
                break;
            case "MSG_SPLITSCREEN_REMOVEUSER":
            case 1:
                message.type = 1;
                break;
            case "MSG_SPLITSCREEN_TYPE_BITS":
            case 1:
                message.type = 1;
                break;
            }
            if (object.slot != null)
                message.slot = object.slot | 0;
            if (object.player_index != null)
                message.player_index = object.player_index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_SplitScreen message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_SplitScreen
         * @static
         * @param {CSVCMsg_SplitScreen} message CSVCMsg_SplitScreen
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_SplitScreen.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "MSG_SPLITSCREEN_ADDUSER" : 0;
                object.slot = 0;
                object.player_index = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.ESplitScreenMessageType[message.type] : message.type;
            if (message.slot != null && message.hasOwnProperty("slot"))
                object.slot = message.slot;
            if (message.player_index != null && message.hasOwnProperty("player_index"))
                object.player_index = message.player_index;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_SplitScreen to JSON.
         * @function toJSON
         * @memberof CSVCMsg_SplitScreen
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_SplitScreen.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_SplitScreen;
    })();
    
    $root.CSVCMsg_GetCvarValue = (function() {
    
        /**
         * Properties of a CSVCMsg_GetCvarValue.
         * @exports ICSVCMsg_GetCvarValue
         * @interface ICSVCMsg_GetCvarValue
         * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
         * @property {string|null} [cvar_name] CSVCMsg_GetCvarValue cvar_name
         */
    
        /**
         * Constructs a new CSVCMsg_GetCvarValue.
         * @exports CSVCMsg_GetCvarValue
         * @classdesc Represents a CSVCMsg_GetCvarValue.
         * @implements ICSVCMsg_GetCvarValue
         * @constructor
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         */
        function CSVCMsg_GetCvarValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GetCvarValue cookie.
         * @member {number} cookie
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cookie = 0;
    
        /**
         * CSVCMsg_GetCvarValue cvar_name.
         * @member {string} cvar_name
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         */
        CSVCMsg_GetCvarValue.prototype.cvar_name = "";
    
        /**
         * Creates a new CSVCMsg_GetCvarValue instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue instance
         */
        CSVCMsg_GetCvarValue.create = function create(properties) {
            return new CSVCMsg_GetCvarValue(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cookie);
            if (message.cvar_name != null && message.hasOwnProperty("cvar_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cvar_name);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GetCvarValue message, length delimited. Does not implicitly {@link CSVCMsg_GetCvarValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {ICSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GetCvarValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.cvar_name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GetCvarValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GetCvarValue message.
         * @function verify
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GetCvarValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                if (!$util.isInteger(message.cookie))
                    return "cookie: integer expected";
            if (message.cvar_name != null && message.hasOwnProperty("cvar_name"))
                if (!$util.isString(message.cvar_name))
                    return "cvar_name: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GetCvarValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
         */
        CSVCMsg_GetCvarValue.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GetCvarValue)
                return object;
            var message = new $root.CSVCMsg_GetCvarValue();
            if (object.cookie != null)
                message.cookie = object.cookie | 0;
            if (object.cvar_name != null)
                message.cvar_name = String(object.cvar_name);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GetCvarValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GetCvarValue
         * @static
         * @param {CSVCMsg_GetCvarValue} message CSVCMsg_GetCvarValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GetCvarValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cookie = 0;
                object.cvar_name = "";
            }
            if (message.cookie != null && message.hasOwnProperty("cookie"))
                object.cookie = message.cookie;
            if (message.cvar_name != null && message.hasOwnProperty("cvar_name"))
                object.cvar_name = message.cvar_name;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GetCvarValue to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GetCvarValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GetCvarValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_GetCvarValue;
    })();
    
    $root.CSVCMsg_Menu = (function() {
    
        /**
         * Properties of a CSVCMsg_Menu.
         * @exports ICSVCMsg_Menu
         * @interface ICSVCMsg_Menu
         * @property {number|null} [dialog_type] CSVCMsg_Menu dialog_type
         * @property {Uint8Array|null} [menu_key_values] CSVCMsg_Menu menu_key_values
         */
    
        /**
         * Constructs a new CSVCMsg_Menu.
         * @exports CSVCMsg_Menu
         * @classdesc Represents a CSVCMsg_Menu.
         * @implements ICSVCMsg_Menu
         * @constructor
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         */
        function CSVCMsg_Menu(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Menu dialog_type.
         * @member {number} dialog_type
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.dialog_type = 0;
    
        /**
         * CSVCMsg_Menu menu_key_values.
         * @member {Uint8Array} menu_key_values
         * @memberof CSVCMsg_Menu
         * @instance
         */
        CSVCMsg_Menu.prototype.menu_key_values = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_Menu instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu=} [properties] Properties to set
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu instance
         */
        CSVCMsg_Menu.create = function create(properties) {
            return new CSVCMsg_Menu(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dialog_type != null && message.hasOwnProperty("dialog_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dialog_type);
            if (message.menu_key_values != null && message.hasOwnProperty("menu_key_values"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.menu_key_values);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Menu message, length delimited. Does not implicitly {@link CSVCMsg_Menu.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {ICSVCMsg_Menu} message CSVCMsg_Menu message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Menu.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dialog_type = reader.int32();
                    break;
                case 2:
                    message.menu_key_values = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Menu message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Menu
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Menu.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Menu message.
         * @function verify
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Menu.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dialog_type != null && message.hasOwnProperty("dialog_type"))
                if (!$util.isInteger(message.dialog_type))
                    return "dialog_type: integer expected";
            if (message.menu_key_values != null && message.hasOwnProperty("menu_key_values"))
                if (!(message.menu_key_values && typeof message.menu_key_values.length === "number" || $util.isString(message.menu_key_values)))
                    return "menu_key_values: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Menu message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Menu} CSVCMsg_Menu
         */
        CSVCMsg_Menu.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Menu)
                return object;
            var message = new $root.CSVCMsg_Menu();
            if (object.dialog_type != null)
                message.dialog_type = object.dialog_type | 0;
            if (object.menu_key_values != null)
                if (typeof object.menu_key_values === "string")
                    $util.base64.decode(object.menu_key_values, message.menu_key_values = $util.newBuffer($util.base64.length(object.menu_key_values)), 0);
                else if (object.menu_key_values.length)
                    message.menu_key_values = object.menu_key_values;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Menu message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Menu
         * @static
         * @param {CSVCMsg_Menu} message CSVCMsg_Menu
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Menu.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dialog_type = 0;
                if (options.bytes === String)
                    object.menu_key_values = "";
                else {
                    object.menu_key_values = [];
                    if (options.bytes !== Array)
                        object.menu_key_values = $util.newBuffer(object.menu_key_values);
                }
            }
            if (message.dialog_type != null && message.hasOwnProperty("dialog_type"))
                object.dialog_type = message.dialog_type;
            if (message.menu_key_values != null && message.hasOwnProperty("menu_key_values"))
                object.menu_key_values = options.bytes === String ? $util.base64.encode(message.menu_key_values, 0, message.menu_key_values.length) : options.bytes === Array ? Array.prototype.slice.call(message.menu_key_values) : message.menu_key_values;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Menu to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Menu
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Menu.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Menu;
    })();
    
    $root.CSVCMsg_UserMessage = (function() {
    
        /**
         * Properties of a CSVCMsg_UserMessage.
         * @exports ICSVCMsg_UserMessage
         * @interface ICSVCMsg_UserMessage
         * @property {number|null} [msg_type] CSVCMsg_UserMessage msg_type
         * @property {Uint8Array|null} [msg_data] CSVCMsg_UserMessage msg_data
         * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough
         */
    
        /**
         * Constructs a new CSVCMsg_UserMessage.
         * @exports CSVCMsg_UserMessage
         * @classdesc Represents a CSVCMsg_UserMessage.
         * @implements ICSVCMsg_UserMessage
         * @constructor
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         */
        function CSVCMsg_UserMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_UserMessage msg_type.
         * @member {number} msg_type
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_type = 0;
    
        /**
         * CSVCMsg_UserMessage msg_data.
         * @member {Uint8Array} msg_data
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.msg_data = $util.newBuffer([]);
    
        /**
         * CSVCMsg_UserMessage passthrough.
         * @member {number} passthrough
         * @memberof CSVCMsg_UserMessage
         * @instance
         */
        CSVCMsg_UserMessage.prototype.passthrough = 0;
    
        /**
         * Creates a new CSVCMsg_UserMessage instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage instance
         */
        CSVCMsg_UserMessage.create = function create(properties) {
            return new CSVCMsg_UserMessage(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.msg_type);
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_data);
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.passthrough);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_UserMessage message, length delimited. Does not implicitly {@link CSVCMsg_UserMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {ICSVCMsg_UserMessage} message CSVCMsg_UserMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_UserMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_type = reader.int32();
                    break;
                case 2:
                    message.msg_data = reader.bytes();
                    break;
                case 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_UserMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_UserMessage message.
         * @function verify
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_UserMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                if (!$util.isInteger(message.msg_type))
                    return "msg_type: integer expected";
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                if (!(message.msg_data && typeof message.msg_data.length === "number" || $util.isString(message.msg_data)))
                    return "msg_data: buffer expected";
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                if (!$util.isInteger(message.passthrough))
                    return "passthrough: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_UserMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
         */
        CSVCMsg_UserMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_UserMessage)
                return object;
            var message = new $root.CSVCMsg_UserMessage();
            if (object.msg_type != null)
                message.msg_type = object.msg_type | 0;
            if (object.msg_data != null)
                if (typeof object.msg_data === "string")
                    $util.base64.decode(object.msg_data, message.msg_data = $util.newBuffer($util.base64.length(object.msg_data)), 0);
                else if (object.msg_data.length)
                    message.msg_data = object.msg_data;
            if (object.passthrough != null)
                message.passthrough = object.passthrough | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_UserMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_UserMessage
         * @static
         * @param {CSVCMsg_UserMessage} message CSVCMsg_UserMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_UserMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.msg_type = 0;
                if (options.bytes === String)
                    object.msg_data = "";
                else {
                    object.msg_data = [];
                    if (options.bytes !== Array)
                        object.msg_data = $util.newBuffer(object.msg_data);
                }
                object.passthrough = 0;
            }
            if (message.msg_type != null && message.hasOwnProperty("msg_type"))
                object.msg_type = message.msg_type;
            if (message.msg_data != null && message.hasOwnProperty("msg_data"))
                object.msg_data = options.bytes === String ? $util.base64.encode(message.msg_data, 0, message.msg_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg_data) : message.msg_data;
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                object.passthrough = message.passthrough;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_UserMessage to JSON.
         * @function toJSON
         * @memberof CSVCMsg_UserMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_UserMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_UserMessage;
    })();
    
    $root.CSVCMsg_PaintmapData = (function() {
    
        /**
         * Properties of a CSVCMsg_PaintmapData.
         * @exports ICSVCMsg_PaintmapData
         * @interface ICSVCMsg_PaintmapData
         * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap
         */
    
        /**
         * Constructs a new CSVCMsg_PaintmapData.
         * @exports CSVCMsg_PaintmapData
         * @classdesc Represents a CSVCMsg_PaintmapData.
         * @implements ICSVCMsg_PaintmapData
         * @constructor
         * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set
         */
        function CSVCMsg_PaintmapData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PaintmapData paintmap.
         * @member {Uint8Array} paintmap
         * @memberof CSVCMsg_PaintmapData
         * @instance
         */
        CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_PaintmapData instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set
         * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData instance
         */
        CSVCMsg_PaintmapData.create = function create(properties) {
            return new CSVCMsg_PaintmapData(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PaintmapData message. Does not implicitly {@link CSVCMsg_PaintmapData.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {ICSVCMsg_PaintmapData} message CSVCMsg_PaintmapData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PaintmapData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paintmap != null && message.hasOwnProperty("paintmap"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.paintmap);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PaintmapData message, length delimited. Does not implicitly {@link CSVCMsg_PaintmapData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {ICSVCMsg_PaintmapData} message CSVCMsg_PaintmapData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PaintmapData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PaintmapData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PaintmapData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paintmap = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PaintmapData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PaintmapData message.
         * @function verify
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PaintmapData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paintmap != null && message.hasOwnProperty("paintmap"))
                if (!(message.paintmap && typeof message.paintmap.length === "number" || $util.isString(message.paintmap)))
                    return "paintmap: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PaintmapData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
         */
        CSVCMsg_PaintmapData.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PaintmapData)
                return object;
            var message = new $root.CSVCMsg_PaintmapData();
            if (object.paintmap != null)
                if (typeof object.paintmap === "string")
                    $util.base64.decode(object.paintmap, message.paintmap = $util.newBuffer($util.base64.length(object.paintmap)), 0);
                else if (object.paintmap.length)
                    message.paintmap = object.paintmap;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PaintmapData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PaintmapData
         * @static
         * @param {CSVCMsg_PaintmapData} message CSVCMsg_PaintmapData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PaintmapData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.paintmap = "";
                else {
                    object.paintmap = [];
                    if (options.bytes !== Array)
                        object.paintmap = $util.newBuffer(object.paintmap);
                }
            if (message.paintmap != null && message.hasOwnProperty("paintmap"))
                object.paintmap = options.bytes === String ? $util.base64.encode(message.paintmap, 0, message.paintmap.length) : options.bytes === Array ? Array.prototype.slice.call(message.paintmap) : message.paintmap;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PaintmapData to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PaintmapData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PaintmapData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_PaintmapData;
    })();
    
    $root.CSVCMsg_GameEvent = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEvent.
         * @exports ICSVCMsg_GameEvent
         * @interface ICSVCMsg_GameEvent
         * @property {string|null} [event_name] CSVCMsg_GameEvent event_name
         * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
         * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
         * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough
         */
    
        /**
         * Constructs a new CSVCMsg_GameEvent.
         * @exports CSVCMsg_GameEvent
         * @classdesc Represents a CSVCMsg_GameEvent.
         * @implements ICSVCMsg_GameEvent
         * @constructor
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         */
        function CSVCMsg_GameEvent(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEvent event_name.
         * @member {string} event_name
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.event_name = "";
    
        /**
         * CSVCMsg_GameEvent eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.eventid = 0;
    
        /**
         * CSVCMsg_GameEvent keys.
         * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    
        /**
         * CSVCMsg_GameEvent passthrough.
         * @member {number} passthrough
         * @memberof CSVCMsg_GameEvent
         * @instance
         */
        CSVCMsg_GameEvent.prototype.passthrough = 0;
    
        /**
         * Creates a new CSVCMsg_GameEvent instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent instance
         */
        CSVCMsg_GameEvent.create = function create(properties) {
            return new CSVCMsg_GameEvent(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.event_name);
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventid);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.CSVCMsg_GameEvent.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.passthrough);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEvent message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {ICSVCMsg_GameEvent} message CSVCMsg_GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event_name = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEvent message.
         * @function verify
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                if (!$util.isString(message.event_name))
                    return "event_name: string expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.CSVCMsg_GameEvent.key_t.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                if (!$util.isInteger(message.passthrough))
                    return "passthrough: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
         */
        CSVCMsg_GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEvent)
                return object;
            var message = new $root.CSVCMsg_GameEvent();
            if (object.event_name != null)
                message.event_name = String(object.event_name);
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".CSVCMsg_GameEvent.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEvent.keys: object expected");
                    message.keys[i] = $root.CSVCMsg_GameEvent.key_t.fromObject(object.keys[i]);
                }
            }
            if (object.passthrough != null)
                message.passthrough = object.passthrough | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEvent
         * @static
         * @param {CSVCMsg_GameEvent} message CSVCMsg_GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.event_name = "";
                object.eventid = 0;
                object.passthrough = 0;
            }
            if (message.event_name != null && message.hasOwnProperty("event_name"))
                object.event_name = message.event_name;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.CSVCMsg_GameEvent.key_t.toObject(message.keys[j], options);
            }
            if (message.passthrough != null && message.hasOwnProperty("passthrough"))
                object.passthrough = message.passthrough;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEvent to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEvent.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEvent
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [val_string] key_t val_string
             * @property {number|null} [val_float] key_t val_float
             * @property {number|null} [val_long] key_t val_long
             * @property {number|null} [val_short] key_t val_short
             * @property {number|null} [val_byte] key_t val_byte
             * @property {boolean|null} [val_bool] key_t val_bool
             * @property {number|Long|null} [val_uint64] key_t val_uint64
             * @property {Uint8Array|null} [val_wstring] key_t val_wstring
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEvent
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t val_string.
             * @member {string} val_string
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_string = "";
    
            /**
             * key_t val_float.
             * @member {number} val_float
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_float = 0;
    
            /**
             * key_t val_long.
             * @member {number} val_long
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_long = 0;
    
            /**
             * key_t val_short.
             * @member {number} val_short
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_short = 0;
    
            /**
             * key_t val_byte.
             * @member {number} val_byte
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_byte = 0;
    
            /**
             * key_t val_bool.
             * @member {boolean} val_bool
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_bool = false;
    
            /**
             * key_t val_uint64.
             * @member {number|Long} val_uint64
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_uint64 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * key_t val_wstring.
             * @member {Uint8Array} val_wstring
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             */
            key_t.prototype.val_wstring = $util.newBuffer([]);
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEvent.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.val_string);
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.val_float);
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.val_long);
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.val_short);
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.val_byte);
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.val_bool);
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.val_uint64);
                if (message.val_wstring != null && message.hasOwnProperty("val_wstring"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.val_wstring);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEvent.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.val_string = reader.string();
                        break;
                    case 3:
                        message.val_float = reader.float();
                        break;
                    case 4:
                        message.val_long = reader.int32();
                        break;
                    case 5:
                        message.val_short = reader.int32();
                        break;
                    case 6:
                        message.val_byte = reader.int32();
                        break;
                    case 7:
                        message.val_bool = reader.bool();
                        break;
                    case 8:
                        message.val_uint64 = reader.uint64();
                        break;
                    case 9:
                        message.val_wstring = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    if (!$util.isString(message.val_string))
                        return "val_string: string expected";
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    if (typeof message.val_float !== "number")
                        return "val_float: number expected";
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    if (!$util.isInteger(message.val_long))
                        return "val_long: integer expected";
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    if (!$util.isInteger(message.val_short))
                        return "val_short: integer expected";
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    if (!$util.isInteger(message.val_byte))
                        return "val_byte: integer expected";
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    if (typeof message.val_bool !== "boolean")
                        return "val_bool: boolean expected";
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (!$util.isInteger(message.val_uint64) && !(message.val_uint64 && $util.isInteger(message.val_uint64.low) && $util.isInteger(message.val_uint64.high)))
                        return "val_uint64: integer|Long expected";
                if (message.val_wstring != null && message.hasOwnProperty("val_wstring"))
                    if (!(message.val_wstring && typeof message.val_wstring.length === "number" || $util.isString(message.val_wstring)))
                        return "val_wstring: buffer expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEvent.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEvent.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEvent.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.val_string != null)
                    message.val_string = String(object.val_string);
                if (object.val_float != null)
                    message.val_float = Number(object.val_float);
                if (object.val_long != null)
                    message.val_long = object.val_long | 0;
                if (object.val_short != null)
                    message.val_short = object.val_short | 0;
                if (object.val_byte != null)
                    message.val_byte = object.val_byte | 0;
                if (object.val_bool != null)
                    message.val_bool = Boolean(object.val_bool);
                if (object.val_uint64 != null)
                    if ($util.Long)
                        (message.val_uint64 = $util.Long.fromValue(object.val_uint64)).unsigned = true;
                    else if (typeof object.val_uint64 === "string")
                        message.val_uint64 = parseInt(object.val_uint64, 10);
                    else if (typeof object.val_uint64 === "number")
                        message.val_uint64 = object.val_uint64;
                    else if (typeof object.val_uint64 === "object")
                        message.val_uint64 = new $util.LongBits(object.val_uint64.low >>> 0, object.val_uint64.high >>> 0).toNumber(true);
                if (object.val_wstring != null)
                    if (typeof object.val_wstring === "string")
                        $util.base64.decode(object.val_wstring, message.val_wstring = $util.newBuffer($util.base64.length(object.val_wstring)), 0);
                    else if (object.val_wstring.length)
                        message.val_wstring = object.val_wstring;
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEvent.key_t
             * @static
             * @param {CSVCMsg_GameEvent.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.val_string = "";
                    object.val_float = 0;
                    object.val_long = 0;
                    object.val_short = 0;
                    object.val_byte = 0;
                    object.val_bool = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.val_uint64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.val_uint64 = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.val_wstring = "";
                    else {
                        object.val_wstring = [];
                        if (options.bytes !== Array)
                            object.val_wstring = $util.newBuffer(object.val_wstring);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.val_string != null && message.hasOwnProperty("val_string"))
                    object.val_string = message.val_string;
                if (message.val_float != null && message.hasOwnProperty("val_float"))
                    object.val_float = options.json && !isFinite(message.val_float) ? String(message.val_float) : message.val_float;
                if (message.val_long != null && message.hasOwnProperty("val_long"))
                    object.val_long = message.val_long;
                if (message.val_short != null && message.hasOwnProperty("val_short"))
                    object.val_short = message.val_short;
                if (message.val_byte != null && message.hasOwnProperty("val_byte"))
                    object.val_byte = message.val_byte;
                if (message.val_bool != null && message.hasOwnProperty("val_bool"))
                    object.val_bool = message.val_bool;
                if (message.val_uint64 != null && message.hasOwnProperty("val_uint64"))
                    if (typeof message.val_uint64 === "number")
                        object.val_uint64 = options.longs === String ? String(message.val_uint64) : message.val_uint64;
                    else
                        object.val_uint64 = options.longs === String ? $util.Long.prototype.toString.call(message.val_uint64) : options.longs === Number ? new $util.LongBits(message.val_uint64.low >>> 0, message.val_uint64.high >>> 0).toNumber(true) : message.val_uint64;
                if (message.val_wstring != null && message.hasOwnProperty("val_wstring"))
                    object.val_wstring = options.bytes === String ? $util.base64.encode(message.val_wstring, 0, message.val_wstring.length) : options.bytes === Array ? Array.prototype.slice.call(message.val_wstring) : message.val_wstring;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEvent.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        return CSVCMsg_GameEvent;
    })();
    
    $root.CSVCMsg_GameEventList = (function() {
    
        /**
         * Properties of a CSVCMsg_GameEventList.
         * @exports ICSVCMsg_GameEventList
         * @interface ICSVCMsg_GameEventList
         * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
         */
    
        /**
         * Constructs a new CSVCMsg_GameEventList.
         * @exports CSVCMsg_GameEventList
         * @classdesc Represents a CSVCMsg_GameEventList.
         * @implements ICSVCMsg_GameEventList
         * @constructor
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         */
        function CSVCMsg_GameEventList(properties) {
            this.descriptors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_GameEventList descriptors.
         * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
         * @memberof CSVCMsg_GameEventList
         * @instance
         */
        CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_GameEventList instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList instance
         */
        CSVCMsg_GameEventList.create = function create(properties) {
            return new CSVCMsg_GameEventList(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.descriptors != null && message.descriptors.length)
                for (var i = 0; i < message.descriptors.length; ++i)
                    $root.CSVCMsg_GameEventList.descriptor_t.encode(message.descriptors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_GameEventList message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {ICSVCMsg_GameEventList} message CSVCMsg_GameEventList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_GameEventList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.descriptors && message.descriptors.length))
                        message.descriptors = [];
                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_GameEventList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_GameEventList message.
         * @function verify
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_GameEventList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.descriptors != null && message.hasOwnProperty("descriptors")) {
                if (!Array.isArray(message.descriptors))
                    return "descriptors: array expected";
                for (var i = 0; i < message.descriptors.length; ++i) {
                    var error = $root.CSVCMsg_GameEventList.descriptor_t.verify(message.descriptors[i]);
                    if (error)
                        return "descriptors." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_GameEventList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
         */
        CSVCMsg_GameEventList.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_GameEventList)
                return object;
            var message = new $root.CSVCMsg_GameEventList();
            if (object.descriptors) {
                if (!Array.isArray(object.descriptors))
                    throw TypeError(".CSVCMsg_GameEventList.descriptors: array expected");
                message.descriptors = [];
                for (var i = 0; i < object.descriptors.length; ++i) {
                    if (typeof object.descriptors[i] !== "object")
                        throw TypeError(".CSVCMsg_GameEventList.descriptors: object expected");
                    message.descriptors[i] = $root.CSVCMsg_GameEventList.descriptor_t.fromObject(object.descriptors[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_GameEventList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_GameEventList
         * @static
         * @param {CSVCMsg_GameEventList} message CSVCMsg_GameEventList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_GameEventList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.descriptors = [];
            if (message.descriptors && message.descriptors.length) {
                object.descriptors = [];
                for (var j = 0; j < message.descriptors.length; ++j)
                    object.descriptors[j] = $root.CSVCMsg_GameEventList.descriptor_t.toObject(message.descriptors[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_GameEventList to JSON.
         * @function toJSON
         * @memberof CSVCMsg_GameEventList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_GameEventList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_GameEventList.key_t = (function() {
    
            /**
             * Properties of a key_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Ikey_t
             * @property {number|null} [type] key_t type
             * @property {string|null} [name] key_t name
             */
    
            /**
             * Constructs a new key_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a key_t.
             * @implements Ikey_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             */
            function key_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * key_t type.
             * @member {number} type
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.type = 0;
    
            /**
             * key_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             */
            key_t.prototype.name = "";
    
            /**
             * Creates a new key_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.key_t} key_t instance
             */
            key_t.create = function create(properties) {
                return new key_t(properties);
            };
    
            /**
             * Encodes the specified key_t message. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified key_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.key_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.Ikey_t} message key_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            key_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a key_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            key_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a key_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            key_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a key_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.key_t} key_t
             */
            key_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.key_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.key_t();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a key_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.key_t
             * @static
             * @param {CSVCMsg_GameEventList.key_t} message key_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            key_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.name = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this key_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.key_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            key_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return key_t;
        })();
    
        CSVCMsg_GameEventList.descriptor_t = (function() {
    
            /**
             * Properties of a descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @interface Idescriptor_t
             * @property {number|null} [eventid] descriptor_t eventid
             * @property {string|null} [name] descriptor_t name
             * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
             */
    
            /**
             * Constructs a new descriptor_t.
             * @memberof CSVCMsg_GameEventList
             * @classdesc Represents a descriptor_t.
             * @implements Idescriptor_t
             * @constructor
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             */
            function descriptor_t(properties) {
                this.keys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * descriptor_t eventid.
             * @member {number} eventid
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.eventid = 0;
    
            /**
             * descriptor_t name.
             * @member {string} name
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.name = "";
    
            /**
             * descriptor_t keys.
             * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             */
            descriptor_t.prototype.keys = $util.emptyArray;
    
            /**
             * Creates a new descriptor_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t instance
             */
            descriptor_t.create = function create(properties) {
                return new descriptor_t(properties);
            };
    
            /**
             * Encodes the specified descriptor_t message. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventid);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.keys != null && message.keys.length)
                    for (var i = 0; i < message.keys.length; ++i)
                        $root.CSVCMsg_GameEventList.key_t.encode(message.keys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified descriptor_t message, length delimited. Does not implicitly {@link CSVCMsg_GameEventList.descriptor_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.Idescriptor_t} message descriptor_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            descriptor_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eventid = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a descriptor_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            descriptor_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a descriptor_t message.
             * @function verify
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            descriptor_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    if (!$util.isInteger(message.eventid))
                        return "eventid: integer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (var i = 0; i < message.keys.length; ++i) {
                        var error = $root.CSVCMsg_GameEventList.key_t.verify(message.keys[i]);
                        if (error)
                            return "keys." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a descriptor_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
             */
            descriptor_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_GameEventList.descriptor_t)
                    return object;
                var message = new $root.CSVCMsg_GameEventList.descriptor_t();
                if (object.eventid != null)
                    message.eventid = object.eventid | 0;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: array expected");
                    message.keys = [];
                    for (var i = 0; i < object.keys.length; ++i) {
                        if (typeof object.keys[i] !== "object")
                            throw TypeError(".CSVCMsg_GameEventList.descriptor_t.keys: object expected");
                        message.keys[i] = $root.CSVCMsg_GameEventList.key_t.fromObject(object.keys[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a descriptor_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @static
             * @param {CSVCMsg_GameEventList.descriptor_t} message descriptor_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            descriptor_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (options.defaults) {
                    object.eventid = 0;
                    object.name = "";
                }
                if (message.eventid != null && message.hasOwnProperty("eventid"))
                    object.eventid = message.eventid;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (var j = 0; j < message.keys.length; ++j)
                        object.keys[j] = $root.CSVCMsg_GameEventList.key_t.toObject(message.keys[j], options);
                }
                return object;
            };
    
            /**
             * Converts this descriptor_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_GameEventList.descriptor_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            descriptor_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return descriptor_t;
        })();
    
        return CSVCMsg_GameEventList;
    })();
    
    $root.CSVCMsg_TempEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_TempEntities.
         * @exports ICSVCMsg_TempEntities
         * @interface ICSVCMsg_TempEntities
         * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
         * @property {number|null} [num_entries] CSVCMsg_TempEntities num_entries
         * @property {Uint8Array|null} [entity_data] CSVCMsg_TempEntities entity_data
         */
    
        /**
         * Constructs a new CSVCMsg_TempEntities.
         * @exports CSVCMsg_TempEntities
         * @classdesc Represents a CSVCMsg_TempEntities.
         * @implements ICSVCMsg_TempEntities
         * @constructor
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         */
        function CSVCMsg_TempEntities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_TempEntities reliable.
         * @member {boolean} reliable
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.reliable = false;
    
        /**
         * CSVCMsg_TempEntities num_entries.
         * @member {number} num_entries
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.num_entries = 0;
    
        /**
         * CSVCMsg_TempEntities entity_data.
         * @member {Uint8Array} entity_data
         * @memberof CSVCMsg_TempEntities
         * @instance
         */
        CSVCMsg_TempEntities.prototype.entity_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_TempEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities instance
         */
        CSVCMsg_TempEntities.create = function create(properties) {
            return new CSVCMsg_TempEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliable);
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num_entries);
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.entity_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_TempEntities message, length delimited. Does not implicitly {@link CSVCMsg_TempEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {ICSVCMsg_TempEntities} message CSVCMsg_TempEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_TempEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reliable = reader.bool();
                    break;
                case 2:
                    message.num_entries = reader.int32();
                    break;
                case 3:
                    message.entity_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_TempEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_TempEntities message.
         * @function verify
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_TempEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                if (typeof message.reliable !== "boolean")
                    return "reliable: boolean expected";
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                if (!$util.isInteger(message.num_entries))
                    return "num_entries: integer expected";
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                if (!(message.entity_data && typeof message.entity_data.length === "number" || $util.isString(message.entity_data)))
                    return "entity_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_TempEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
         */
        CSVCMsg_TempEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_TempEntities)
                return object;
            var message = new $root.CSVCMsg_TempEntities();
            if (object.reliable != null)
                message.reliable = Boolean(object.reliable);
            if (object.num_entries != null)
                message.num_entries = object.num_entries | 0;
            if (object.entity_data != null)
                if (typeof object.entity_data === "string")
                    $util.base64.decode(object.entity_data, message.entity_data = $util.newBuffer($util.base64.length(object.entity_data)), 0);
                else if (object.entity_data.length)
                    message.entity_data = object.entity_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_TempEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_TempEntities
         * @static
         * @param {CSVCMsg_TempEntities} message CSVCMsg_TempEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_TempEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reliable = false;
                object.num_entries = 0;
                if (options.bytes === String)
                    object.entity_data = "";
                else {
                    object.entity_data = [];
                    if (options.bytes !== Array)
                        object.entity_data = $util.newBuffer(object.entity_data);
                }
            }
            if (message.reliable != null && message.hasOwnProperty("reliable"))
                object.reliable = message.reliable;
            if (message.num_entries != null && message.hasOwnProperty("num_entries"))
                object.num_entries = message.num_entries;
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                object.entity_data = options.bytes === String ? $util.base64.encode(message.entity_data, 0, message.entity_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.entity_data) : message.entity_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_TempEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_TempEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_TempEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_TempEntities;
    })();
    
    $root.CSVCMsg_PacketEntities = (function() {
    
        /**
         * Properties of a CSVCMsg_PacketEntities.
         * @exports ICSVCMsg_PacketEntities
         * @interface ICSVCMsg_PacketEntities
         * @property {number|null} [max_entries] CSVCMsg_PacketEntities max_entries
         * @property {number|null} [updated_entries] CSVCMsg_PacketEntities updated_entries
         * @property {boolean|null} [is_delta] CSVCMsg_PacketEntities is_delta
         * @property {boolean|null} [update_baseline] CSVCMsg_PacketEntities update_baseline
         * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
         * @property {number|null} [delta_from] CSVCMsg_PacketEntities delta_from
         * @property {Uint8Array|null} [entity_data] CSVCMsg_PacketEntities entity_data
         */
    
        /**
         * Constructs a new CSVCMsg_PacketEntities.
         * @exports CSVCMsg_PacketEntities
         * @classdesc Represents a CSVCMsg_PacketEntities.
         * @implements ICSVCMsg_PacketEntities
         * @constructor
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         */
        function CSVCMsg_PacketEntities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_PacketEntities max_entries.
         * @member {number} max_entries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.max_entries = 0;
    
        /**
         * CSVCMsg_PacketEntities updated_entries.
         * @member {number} updated_entries
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.updated_entries = 0;
    
        /**
         * CSVCMsg_PacketEntities is_delta.
         * @member {boolean} is_delta
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.is_delta = false;
    
        /**
         * CSVCMsg_PacketEntities update_baseline.
         * @member {boolean} update_baseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.update_baseline = false;
    
        /**
         * CSVCMsg_PacketEntities baseline.
         * @member {number} baseline
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.baseline = 0;
    
        /**
         * CSVCMsg_PacketEntities delta_from.
         * @member {number} delta_from
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.delta_from = 0;
    
        /**
         * CSVCMsg_PacketEntities entity_data.
         * @member {Uint8Array} entity_data
         * @memberof CSVCMsg_PacketEntities
         * @instance
         */
        CSVCMsg_PacketEntities.prototype.entity_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_PacketEntities instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities instance
         */
        CSVCMsg_PacketEntities.create = function create(properties) {
            return new CSVCMsg_PacketEntities(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.max_entries);
            if (message.updated_entries != null && message.hasOwnProperty("updated_entries"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.updated_entries);
            if (message.is_delta != null && message.hasOwnProperty("is_delta"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_delta);
            if (message.update_baseline != null && message.hasOwnProperty("update_baseline"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.update_baseline);
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.baseline);
            if (message.delta_from != null && message.hasOwnProperty("delta_from"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.delta_from);
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.entity_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_PacketEntities message, length delimited. Does not implicitly {@link CSVCMsg_PacketEntities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {ICSVCMsg_PacketEntities} message CSVCMsg_PacketEntities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_PacketEntities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.max_entries = reader.int32();
                    break;
                case 2:
                    message.updated_entries = reader.int32();
                    break;
                case 3:
                    message.is_delta = reader.bool();
                    break;
                case 4:
                    message.update_baseline = reader.bool();
                    break;
                case 5:
                    message.baseline = reader.int32();
                    break;
                case 6:
                    message.delta_from = reader.int32();
                    break;
                case 7:
                    message.entity_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_PacketEntities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_PacketEntities message.
         * @function verify
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_PacketEntities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                if (!$util.isInteger(message.max_entries))
                    return "max_entries: integer expected";
            if (message.updated_entries != null && message.hasOwnProperty("updated_entries"))
                if (!$util.isInteger(message.updated_entries))
                    return "updated_entries: integer expected";
            if (message.is_delta != null && message.hasOwnProperty("is_delta"))
                if (typeof message.is_delta !== "boolean")
                    return "is_delta: boolean expected";
            if (message.update_baseline != null && message.hasOwnProperty("update_baseline"))
                if (typeof message.update_baseline !== "boolean")
                    return "update_baseline: boolean expected";
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                if (!$util.isInteger(message.baseline))
                    return "baseline: integer expected";
            if (message.delta_from != null && message.hasOwnProperty("delta_from"))
                if (!$util.isInteger(message.delta_from))
                    return "delta_from: integer expected";
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                if (!(message.entity_data && typeof message.entity_data.length === "number" || $util.isString(message.entity_data)))
                    return "entity_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_PacketEntities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
         */
        CSVCMsg_PacketEntities.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_PacketEntities)
                return object;
            var message = new $root.CSVCMsg_PacketEntities();
            if (object.max_entries != null)
                message.max_entries = object.max_entries | 0;
            if (object.updated_entries != null)
                message.updated_entries = object.updated_entries | 0;
            if (object.is_delta != null)
                message.is_delta = Boolean(object.is_delta);
            if (object.update_baseline != null)
                message.update_baseline = Boolean(object.update_baseline);
            if (object.baseline != null)
                message.baseline = object.baseline | 0;
            if (object.delta_from != null)
                message.delta_from = object.delta_from | 0;
            if (object.entity_data != null)
                if (typeof object.entity_data === "string")
                    $util.base64.decode(object.entity_data, message.entity_data = $util.newBuffer($util.base64.length(object.entity_data)), 0);
                else if (object.entity_data.length)
                    message.entity_data = object.entity_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_PacketEntities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_PacketEntities
         * @static
         * @param {CSVCMsg_PacketEntities} message CSVCMsg_PacketEntities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_PacketEntities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.max_entries = 0;
                object.updated_entries = 0;
                object.is_delta = false;
                object.update_baseline = false;
                object.baseline = 0;
                object.delta_from = 0;
                if (options.bytes === String)
                    object.entity_data = "";
                else {
                    object.entity_data = [];
                    if (options.bytes !== Array)
                        object.entity_data = $util.newBuffer(object.entity_data);
                }
            }
            if (message.max_entries != null && message.hasOwnProperty("max_entries"))
                object.max_entries = message.max_entries;
            if (message.updated_entries != null && message.hasOwnProperty("updated_entries"))
                object.updated_entries = message.updated_entries;
            if (message.is_delta != null && message.hasOwnProperty("is_delta"))
                object.is_delta = message.is_delta;
            if (message.update_baseline != null && message.hasOwnProperty("update_baseline"))
                object.update_baseline = message.update_baseline;
            if (message.baseline != null && message.hasOwnProperty("baseline"))
                object.baseline = message.baseline;
            if (message.delta_from != null && message.hasOwnProperty("delta_from"))
                object.delta_from = message.delta_from;
            if (message.entity_data != null && message.hasOwnProperty("entity_data"))
                object.entity_data = options.bytes === String ? $util.base64.encode(message.entity_data, 0, message.entity_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.entity_data) : message.entity_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_PacketEntities to JSON.
         * @function toJSON
         * @memberof CSVCMsg_PacketEntities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_PacketEntities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_PacketEntities;
    })();
    
    $root.CSVCMsg_Sounds = (function() {
    
        /**
         * Properties of a CSVCMsg_Sounds.
         * @exports ICSVCMsg_Sounds
         * @interface ICSVCMsg_Sounds
         * @property {boolean|null} [reliable_sound] CSVCMsg_Sounds reliable_sound
         * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
         */
    
        /**
         * Constructs a new CSVCMsg_Sounds.
         * @exports CSVCMsg_Sounds
         * @classdesc Represents a CSVCMsg_Sounds.
         * @implements ICSVCMsg_Sounds
         * @constructor
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         */
        function CSVCMsg_Sounds(properties) {
            this.sounds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Sounds reliable_sound.
         * @member {boolean} reliable_sound
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.reliable_sound = false;
    
        /**
         * CSVCMsg_Sounds sounds.
         * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
         * @memberof CSVCMsg_Sounds
         * @instance
         */
        CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    
        /**
         * Creates a new CSVCMsg_Sounds instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds=} [properties] Properties to set
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds instance
         */
        CSVCMsg_Sounds.create = function create(properties) {
            return new CSVCMsg_Sounds(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reliable_sound != null && message.hasOwnProperty("reliable_sound"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reliable_sound);
            if (message.sounds != null && message.sounds.length)
                for (var i = 0; i < message.sounds.length; ++i)
                    $root.CSVCMsg_Sounds.sounddata_t.encode(message.sounds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Sounds message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {ICSVCMsg_Sounds} message CSVCMsg_Sounds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Sounds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reliable_sound = reader.bool();
                    break;
                case 2:
                    if (!(message.sounds && message.sounds.length))
                        message.sounds = [];
                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Sounds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Sounds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Sounds message.
         * @function verify
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Sounds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reliable_sound != null && message.hasOwnProperty("reliable_sound"))
                if (typeof message.reliable_sound !== "boolean")
                    return "reliable_sound: boolean expected";
            if (message.sounds != null && message.hasOwnProperty("sounds")) {
                if (!Array.isArray(message.sounds))
                    return "sounds: array expected";
                for (var i = 0; i < message.sounds.length; ++i) {
                    var error = $root.CSVCMsg_Sounds.sounddata_t.verify(message.sounds[i]);
                    if (error)
                        return "sounds." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Sounds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
         */
        CSVCMsg_Sounds.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Sounds)
                return object;
            var message = new $root.CSVCMsg_Sounds();
            if (object.reliable_sound != null)
                message.reliable_sound = Boolean(object.reliable_sound);
            if (object.sounds) {
                if (!Array.isArray(object.sounds))
                    throw TypeError(".CSVCMsg_Sounds.sounds: array expected");
                message.sounds = [];
                for (var i = 0; i < object.sounds.length; ++i) {
                    if (typeof object.sounds[i] !== "object")
                        throw TypeError(".CSVCMsg_Sounds.sounds: object expected");
                    message.sounds[i] = $root.CSVCMsg_Sounds.sounddata_t.fromObject(object.sounds[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Sounds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Sounds
         * @static
         * @param {CSVCMsg_Sounds} message CSVCMsg_Sounds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Sounds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sounds = [];
            if (options.defaults)
                object.reliable_sound = false;
            if (message.reliable_sound != null && message.hasOwnProperty("reliable_sound"))
                object.reliable_sound = message.reliable_sound;
            if (message.sounds && message.sounds.length) {
                object.sounds = [];
                for (var j = 0; j < message.sounds.length; ++j)
                    object.sounds[j] = $root.CSVCMsg_Sounds.sounddata_t.toObject(message.sounds[j], options);
            }
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Sounds to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Sounds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Sounds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CSVCMsg_Sounds.sounddata_t = (function() {
    
            /**
             * Properties of a sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @interface Isounddata_t
             * @property {number|null} [origin_x] sounddata_t origin_x
             * @property {number|null} [origin_y] sounddata_t origin_y
             * @property {number|null} [origin_z] sounddata_t origin_z
             * @property {number|null} [volume] sounddata_t volume
             * @property {number|null} [delay_value] sounddata_t delay_value
             * @property {number|null} [sequence_number] sounddata_t sequence_number
             * @property {number|null} [entity_index] sounddata_t entity_index
             * @property {number|null} [channel] sounddata_t channel
             * @property {number|null} [pitch] sounddata_t pitch
             * @property {number|null} [flags] sounddata_t flags
             * @property {number|null} [sound_num] sounddata_t sound_num
             * @property {number|null} [sound_num_handle] sounddata_t sound_num_handle
             * @property {number|null} [speaker_entity] sounddata_t speaker_entity
             * @property {number|null} [random_seed] sounddata_t random_seed
             * @property {number|null} [sound_level] sounddata_t sound_level
             * @property {boolean|null} [is_sentence] sounddata_t is_sentence
             * @property {boolean|null} [is_ambient] sounddata_t is_ambient
             */
    
            /**
             * Constructs a new sounddata_t.
             * @memberof CSVCMsg_Sounds
             * @classdesc Represents a sounddata_t.
             * @implements Isounddata_t
             * @constructor
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             */
            function sounddata_t(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * sounddata_t origin_x.
             * @member {number} origin_x
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_x = 0;
    
            /**
             * sounddata_t origin_y.
             * @member {number} origin_y
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_y = 0;
    
            /**
             * sounddata_t origin_z.
             * @member {number} origin_z
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.origin_z = 0;
    
            /**
             * sounddata_t volume.
             * @member {number} volume
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.volume = 0;
    
            /**
             * sounddata_t delay_value.
             * @member {number} delay_value
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.delay_value = 0;
    
            /**
             * sounddata_t sequence_number.
             * @member {number} sequence_number
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sequence_number = 0;
    
            /**
             * sounddata_t entity_index.
             * @member {number} entity_index
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.entity_index = 0;
    
            /**
             * sounddata_t channel.
             * @member {number} channel
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.channel = 0;
    
            /**
             * sounddata_t pitch.
             * @member {number} pitch
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.pitch = 0;
    
            /**
             * sounddata_t flags.
             * @member {number} flags
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.flags = 0;
    
            /**
             * sounddata_t sound_num.
             * @member {number} sound_num
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_num = 0;
    
            /**
             * sounddata_t sound_num_handle.
             * @member {number} sound_num_handle
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_num_handle = 0;
    
            /**
             * sounddata_t speaker_entity.
             * @member {number} speaker_entity
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.speaker_entity = 0;
    
            /**
             * sounddata_t random_seed.
             * @member {number} random_seed
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.random_seed = 0;
    
            /**
             * sounddata_t sound_level.
             * @member {number} sound_level
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.sound_level = 0;
    
            /**
             * sounddata_t is_sentence.
             * @member {boolean} is_sentence
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.is_sentence = false;
    
            /**
             * sounddata_t is_ambient.
             * @member {boolean} is_ambient
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             */
            sounddata_t.prototype.is_ambient = false;
    
            /**
             * Creates a new sounddata_t instance using the specified properties.
             * @function create
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t instance
             */
            sounddata_t.create = function create(properties) {
                return new sounddata_t(properties);
            };
    
            /**
             * Encodes the specified sounddata_t message. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.origin_x != null && message.hasOwnProperty("origin_x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.origin_x);
                if (message.origin_y != null && message.hasOwnProperty("origin_y"))
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.origin_y);
                if (message.origin_z != null && message.hasOwnProperty("origin_z"))
                    writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.origin_z);
                if (message.volume != null && message.hasOwnProperty("volume"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.volume);
                if (message.delay_value != null && message.hasOwnProperty("delay_value"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.delay_value);
                if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sequence_number);
                if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.entity_index);
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.channel);
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.pitch);
                if (message.flags != null && message.hasOwnProperty("flags"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.flags);
                if (message.sound_num != null && message.hasOwnProperty("sound_num"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sound_num);
                if (message.sound_num_handle != null && message.hasOwnProperty("sound_num_handle"))
                    writer.uint32(/* id 12, wireType 5 =*/101).fixed32(message.sound_num_handle);
                if (message.speaker_entity != null && message.hasOwnProperty("speaker_entity"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.speaker_entity);
                if (message.random_seed != null && message.hasOwnProperty("random_seed"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.random_seed);
                if (message.sound_level != null && message.hasOwnProperty("sound_level"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.sound_level);
                if (message.is_sentence != null && message.hasOwnProperty("is_sentence"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.is_sentence);
                if (message.is_ambient != null && message.hasOwnProperty("is_ambient"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.is_ambient);
                return writer;
            };
    
            /**
             * Encodes the specified sounddata_t message, length delimited. Does not implicitly {@link CSVCMsg_Sounds.sounddata_t.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.Isounddata_t} message sounddata_t message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            sounddata_t.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer.
             * @function decode
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.origin_x = reader.sint32();
                        break;
                    case 2:
                        message.origin_y = reader.sint32();
                        break;
                    case 3:
                        message.origin_z = reader.sint32();
                        break;
                    case 4:
                        message.volume = reader.uint32();
                        break;
                    case 5:
                        message.delay_value = reader.float();
                        break;
                    case 6:
                        message.sequence_number = reader.int32();
                        break;
                    case 7:
                        message.entity_index = reader.int32();
                        break;
                    case 8:
                        message.channel = reader.int32();
                        break;
                    case 9:
                        message.pitch = reader.int32();
                        break;
                    case 10:
                        message.flags = reader.int32();
                        break;
                    case 11:
                        message.sound_num = reader.uint32();
                        break;
                    case 12:
                        message.sound_num_handle = reader.fixed32();
                        break;
                    case 13:
                        message.speaker_entity = reader.int32();
                        break;
                    case 14:
                        message.random_seed = reader.int32();
                        break;
                    case 15:
                        message.sound_level = reader.int32();
                        break;
                    case 16:
                        message.is_sentence = reader.bool();
                        break;
                    case 17:
                        message.is_ambient = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a sounddata_t message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            sounddata_t.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a sounddata_t message.
             * @function verify
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            sounddata_t.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.origin_x != null && message.hasOwnProperty("origin_x"))
                    if (!$util.isInteger(message.origin_x))
                        return "origin_x: integer expected";
                if (message.origin_y != null && message.hasOwnProperty("origin_y"))
                    if (!$util.isInteger(message.origin_y))
                        return "origin_y: integer expected";
                if (message.origin_z != null && message.hasOwnProperty("origin_z"))
                    if (!$util.isInteger(message.origin_z))
                        return "origin_z: integer expected";
                if (message.volume != null && message.hasOwnProperty("volume"))
                    if (!$util.isInteger(message.volume))
                        return "volume: integer expected";
                if (message.delay_value != null && message.hasOwnProperty("delay_value"))
                    if (typeof message.delay_value !== "number")
                        return "delay_value: number expected";
                if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                    if (!$util.isInteger(message.sequence_number))
                        return "sequence_number: integer expected";
                if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                    if (!$util.isInteger(message.entity_index))
                        return "entity_index: integer expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isInteger(message.channel))
                        return "channel: integer expected";
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    if (!$util.isInteger(message.pitch))
                        return "pitch: integer expected";
                if (message.flags != null && message.hasOwnProperty("flags"))
                    if (!$util.isInteger(message.flags))
                        return "flags: integer expected";
                if (message.sound_num != null && message.hasOwnProperty("sound_num"))
                    if (!$util.isInteger(message.sound_num))
                        return "sound_num: integer expected";
                if (message.sound_num_handle != null && message.hasOwnProperty("sound_num_handle"))
                    if (!$util.isInteger(message.sound_num_handle))
                        return "sound_num_handle: integer expected";
                if (message.speaker_entity != null && message.hasOwnProperty("speaker_entity"))
                    if (!$util.isInteger(message.speaker_entity))
                        return "speaker_entity: integer expected";
                if (message.random_seed != null && message.hasOwnProperty("random_seed"))
                    if (!$util.isInteger(message.random_seed))
                        return "random_seed: integer expected";
                if (message.sound_level != null && message.hasOwnProperty("sound_level"))
                    if (!$util.isInteger(message.sound_level))
                        return "sound_level: integer expected";
                if (message.is_sentence != null && message.hasOwnProperty("is_sentence"))
                    if (typeof message.is_sentence !== "boolean")
                        return "is_sentence: boolean expected";
                if (message.is_ambient != null && message.hasOwnProperty("is_ambient"))
                    if (typeof message.is_ambient !== "boolean")
                        return "is_ambient: boolean expected";
                return null;
            };
    
            /**
             * Creates a sounddata_t message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
             */
            sounddata_t.fromObject = function fromObject(object) {
                if (object instanceof $root.CSVCMsg_Sounds.sounddata_t)
                    return object;
                var message = new $root.CSVCMsg_Sounds.sounddata_t();
                if (object.origin_x != null)
                    message.origin_x = object.origin_x | 0;
                if (object.origin_y != null)
                    message.origin_y = object.origin_y | 0;
                if (object.origin_z != null)
                    message.origin_z = object.origin_z | 0;
                if (object.volume != null)
                    message.volume = object.volume >>> 0;
                if (object.delay_value != null)
                    message.delay_value = Number(object.delay_value);
                if (object.sequence_number != null)
                    message.sequence_number = object.sequence_number | 0;
                if (object.entity_index != null)
                    message.entity_index = object.entity_index | 0;
                if (object.channel != null)
                    message.channel = object.channel | 0;
                if (object.pitch != null)
                    message.pitch = object.pitch | 0;
                if (object.flags != null)
                    message.flags = object.flags | 0;
                if (object.sound_num != null)
                    message.sound_num = object.sound_num >>> 0;
                if (object.sound_num_handle != null)
                    message.sound_num_handle = object.sound_num_handle >>> 0;
                if (object.speaker_entity != null)
                    message.speaker_entity = object.speaker_entity | 0;
                if (object.random_seed != null)
                    message.random_seed = object.random_seed | 0;
                if (object.sound_level != null)
                    message.sound_level = object.sound_level | 0;
                if (object.is_sentence != null)
                    message.is_sentence = Boolean(object.is_sentence);
                if (object.is_ambient != null)
                    message.is_ambient = Boolean(object.is_ambient);
                return message;
            };
    
            /**
             * Creates a plain object from a sounddata_t message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @static
             * @param {CSVCMsg_Sounds.sounddata_t} message sounddata_t
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            sounddata_t.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.origin_x = 0;
                    object.origin_y = 0;
                    object.origin_z = 0;
                    object.volume = 0;
                    object.delay_value = 0;
                    object.sequence_number = 0;
                    object.entity_index = 0;
                    object.channel = 0;
                    object.pitch = 0;
                    object.flags = 0;
                    object.sound_num = 0;
                    object.sound_num_handle = 0;
                    object.speaker_entity = 0;
                    object.random_seed = 0;
                    object.sound_level = 0;
                    object.is_sentence = false;
                    object.is_ambient = false;
                }
                if (message.origin_x != null && message.hasOwnProperty("origin_x"))
                    object.origin_x = message.origin_x;
                if (message.origin_y != null && message.hasOwnProperty("origin_y"))
                    object.origin_y = message.origin_y;
                if (message.origin_z != null && message.hasOwnProperty("origin_z"))
                    object.origin_z = message.origin_z;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = message.volume;
                if (message.delay_value != null && message.hasOwnProperty("delay_value"))
                    object.delay_value = options.json && !isFinite(message.delay_value) ? String(message.delay_value) : message.delay_value;
                if (message.sequence_number != null && message.hasOwnProperty("sequence_number"))
                    object.sequence_number = message.sequence_number;
                if (message.entity_index != null && message.hasOwnProperty("entity_index"))
                    object.entity_index = message.entity_index;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    object.pitch = message.pitch;
                if (message.flags != null && message.hasOwnProperty("flags"))
                    object.flags = message.flags;
                if (message.sound_num != null && message.hasOwnProperty("sound_num"))
                    object.sound_num = message.sound_num;
                if (message.sound_num_handle != null && message.hasOwnProperty("sound_num_handle"))
                    object.sound_num_handle = message.sound_num_handle;
                if (message.speaker_entity != null && message.hasOwnProperty("speaker_entity"))
                    object.speaker_entity = message.speaker_entity;
                if (message.random_seed != null && message.hasOwnProperty("random_seed"))
                    object.random_seed = message.random_seed;
                if (message.sound_level != null && message.hasOwnProperty("sound_level"))
                    object.sound_level = message.sound_level;
                if (message.is_sentence != null && message.hasOwnProperty("is_sentence"))
                    object.is_sentence = message.is_sentence;
                if (message.is_ambient != null && message.hasOwnProperty("is_ambient"))
                    object.is_ambient = message.is_ambient;
                return object;
            };
    
            /**
             * Converts this sounddata_t to JSON.
             * @function toJSON
             * @memberof CSVCMsg_Sounds.sounddata_t
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            sounddata_t.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return sounddata_t;
        })();
    
        return CSVCMsg_Sounds;
    })();
    
    $root.CSVCMsg_EntityMsg = (function() {
    
        /**
         * Properties of a CSVCMsg_EntityMsg.
         * @exports ICSVCMsg_EntityMsg
         * @interface ICSVCMsg_EntityMsg
         * @property {number|null} [ent_index] CSVCMsg_EntityMsg ent_index
         * @property {number|null} [class_id] CSVCMsg_EntityMsg class_id
         * @property {Uint8Array|null} [ent_data] CSVCMsg_EntityMsg ent_data
         */
    
        /**
         * Constructs a new CSVCMsg_EntityMsg.
         * @exports CSVCMsg_EntityMsg
         * @classdesc Represents a CSVCMsg_EntityMsg.
         * @implements ICSVCMsg_EntityMsg
         * @constructor
         * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set
         */
        function CSVCMsg_EntityMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_EntityMsg ent_index.
         * @member {number} ent_index
         * @memberof CSVCMsg_EntityMsg
         * @instance
         */
        CSVCMsg_EntityMsg.prototype.ent_index = 0;
    
        /**
         * CSVCMsg_EntityMsg class_id.
         * @member {number} class_id
         * @memberof CSVCMsg_EntityMsg
         * @instance
         */
        CSVCMsg_EntityMsg.prototype.class_id = 0;
    
        /**
         * CSVCMsg_EntityMsg ent_data.
         * @member {Uint8Array} ent_data
         * @memberof CSVCMsg_EntityMsg
         * @instance
         */
        CSVCMsg_EntityMsg.prototype.ent_data = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_EntityMsg instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set
         * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg instance
         */
        CSVCMsg_EntityMsg.create = function create(properties) {
            return new CSVCMsg_EntityMsg(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_EntityMsg message. Does not implicitly {@link CSVCMsg_EntityMsg.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {ICSVCMsg_EntityMsg} message CSVCMsg_EntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_EntityMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ent_index);
            if (message.class_id != null && message.hasOwnProperty("class_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.class_id);
            if (message.ent_data != null && message.hasOwnProperty("ent_data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ent_data);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_EntityMsg message, length delimited. Does not implicitly {@link CSVCMsg_EntityMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {ICSVCMsg_EntityMsg} message CSVCMsg_EntityMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_EntityMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_EntityMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EntityMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ent_index = reader.int32();
                    break;
                case 2:
                    message.class_id = reader.int32();
                    break;
                case 3:
                    message.ent_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_EntityMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_EntityMsg message.
         * @function verify
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_EntityMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                if (!$util.isInteger(message.ent_index))
                    return "ent_index: integer expected";
            if (message.class_id != null && message.hasOwnProperty("class_id"))
                if (!$util.isInteger(message.class_id))
                    return "class_id: integer expected";
            if (message.ent_data != null && message.hasOwnProperty("ent_data"))
                if (!(message.ent_data && typeof message.ent_data.length === "number" || $util.isString(message.ent_data)))
                    return "ent_data: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_EntityMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
         */
        CSVCMsg_EntityMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_EntityMsg)
                return object;
            var message = new $root.CSVCMsg_EntityMsg();
            if (object.ent_index != null)
                message.ent_index = object.ent_index | 0;
            if (object.class_id != null)
                message.class_id = object.class_id | 0;
            if (object.ent_data != null)
                if (typeof object.ent_data === "string")
                    $util.base64.decode(object.ent_data, message.ent_data = $util.newBuffer($util.base64.length(object.ent_data)), 0);
                else if (object.ent_data.length)
                    message.ent_data = object.ent_data;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_EntityMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_EntityMsg
         * @static
         * @param {CSVCMsg_EntityMsg} message CSVCMsg_EntityMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_EntityMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ent_index = 0;
                object.class_id = 0;
                if (options.bytes === String)
                    object.ent_data = "";
                else {
                    object.ent_data = [];
                    if (options.bytes !== Array)
                        object.ent_data = $util.newBuffer(object.ent_data);
                }
            }
            if (message.ent_index != null && message.hasOwnProperty("ent_index"))
                object.ent_index = message.ent_index;
            if (message.class_id != null && message.hasOwnProperty("class_id"))
                object.class_id = message.class_id;
            if (message.ent_data != null && message.hasOwnProperty("ent_data"))
                object.ent_data = options.bytes === String ? $util.base64.encode(message.ent_data, 0, message.ent_data.length) : options.bytes === Array ? Array.prototype.slice.call(message.ent_data) : message.ent_data;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_EntityMsg to JSON.
         * @function toJSON
         * @memberof CSVCMsg_EntityMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_EntityMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_EntityMsg;
    })();
    
    $root.CSVCMsg_CmdKeyValues = (function() {
    
        /**
         * Properties of a CSVCMsg_CmdKeyValues.
         * @exports ICSVCMsg_CmdKeyValues
         * @interface ICSVCMsg_CmdKeyValues
         * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues
         */
    
        /**
         * Constructs a new CSVCMsg_CmdKeyValues.
         * @exports CSVCMsg_CmdKeyValues
         * @classdesc Represents a CSVCMsg_CmdKeyValues.
         * @implements ICSVCMsg_CmdKeyValues
         * @constructor
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         */
        function CSVCMsg_CmdKeyValues(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_CmdKeyValues keyvalues.
         * @member {Uint8Array} keyvalues
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         */
        CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    
        /**
         * Creates a new CSVCMsg_CmdKeyValues instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues instance
         */
        CSVCMsg_CmdKeyValues.create = function create(properties) {
            return new CSVCMsg_CmdKeyValues(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyvalues);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_CmdKeyValues message, length delimited. Does not implicitly {@link CSVCMsg_CmdKeyValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {ICSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_CmdKeyValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_CmdKeyValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_CmdKeyValues message.
         * @function verify
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_CmdKeyValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                if (!(message.keyvalues && typeof message.keyvalues.length === "number" || $util.isString(message.keyvalues)))
                    return "keyvalues: buffer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_CmdKeyValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
         */
        CSVCMsg_CmdKeyValues.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_CmdKeyValues)
                return object;
            var message = new $root.CSVCMsg_CmdKeyValues();
            if (object.keyvalues != null)
                if (typeof object.keyvalues === "string")
                    $util.base64.decode(object.keyvalues, message.keyvalues = $util.newBuffer($util.base64.length(object.keyvalues)), 0);
                else if (object.keyvalues.length)
                    message.keyvalues = object.keyvalues;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_CmdKeyValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_CmdKeyValues
         * @static
         * @param {CSVCMsg_CmdKeyValues} message CSVCMsg_CmdKeyValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_CmdKeyValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.keyvalues = "";
                else {
                    object.keyvalues = [];
                    if (options.bytes !== Array)
                        object.keyvalues = $util.newBuffer(object.keyvalues);
                }
            if (message.keyvalues != null && message.hasOwnProperty("keyvalues"))
                object.keyvalues = options.bytes === String ? $util.base64.encode(message.keyvalues, 0, message.keyvalues.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyvalues) : message.keyvalues;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_CmdKeyValues to JSON.
         * @function toJSON
         * @memberof CSVCMsg_CmdKeyValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_CmdKeyValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_CmdKeyValues;
    })();
    
    $root.CSVCMsg_EncryptedData = (function() {
    
        /**
         * Properties of a CSVCMsg_EncryptedData.
         * @exports ICSVCMsg_EncryptedData
         * @interface ICSVCMsg_EncryptedData
         * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted
         * @property {number|null} [key_type] CSVCMsg_EncryptedData key_type
         */
    
        /**
         * Constructs a new CSVCMsg_EncryptedData.
         * @exports CSVCMsg_EncryptedData
         * @classdesc Represents a CSVCMsg_EncryptedData.
         * @implements ICSVCMsg_EncryptedData
         * @constructor
         * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set
         */
        function CSVCMsg_EncryptedData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_EncryptedData encrypted.
         * @member {Uint8Array} encrypted
         * @memberof CSVCMsg_EncryptedData
         * @instance
         */
        CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);
    
        /**
         * CSVCMsg_EncryptedData key_type.
         * @member {number} key_type
         * @memberof CSVCMsg_EncryptedData
         * @instance
         */
        CSVCMsg_EncryptedData.prototype.key_type = 0;
    
        /**
         * Creates a new CSVCMsg_EncryptedData instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set
         * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData instance
         */
        CSVCMsg_EncryptedData.create = function create(properties) {
            return new CSVCMsg_EncryptedData(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_EncryptedData message. Does not implicitly {@link CSVCMsg_EncryptedData.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {ICSVCMsg_EncryptedData} message CSVCMsg_EncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_EncryptedData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encrypted != null && message.hasOwnProperty("encrypted"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encrypted);
            if (message.key_type != null && message.hasOwnProperty("key_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.key_type);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_EncryptedData message, length delimited. Does not implicitly {@link CSVCMsg_EncryptedData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {ICSVCMsg_EncryptedData} message CSVCMsg_EncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_EncryptedData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_EncryptedData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EncryptedData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encrypted = reader.bytes();
                    break;
                case 2:
                    message.key_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_EncryptedData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_EncryptedData message.
         * @function verify
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_EncryptedData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encrypted != null && message.hasOwnProperty("encrypted"))
                if (!(message.encrypted && typeof message.encrypted.length === "number" || $util.isString(message.encrypted)))
                    return "encrypted: buffer expected";
            if (message.key_type != null && message.hasOwnProperty("key_type"))
                if (!$util.isInteger(message.key_type))
                    return "key_type: integer expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_EncryptedData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
         */
        CSVCMsg_EncryptedData.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_EncryptedData)
                return object;
            var message = new $root.CSVCMsg_EncryptedData();
            if (object.encrypted != null)
                if (typeof object.encrypted === "string")
                    $util.base64.decode(object.encrypted, message.encrypted = $util.newBuffer($util.base64.length(object.encrypted)), 0);
                else if (object.encrypted.length)
                    message.encrypted = object.encrypted;
            if (object.key_type != null)
                message.key_type = object.key_type | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_EncryptedData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_EncryptedData
         * @static
         * @param {CSVCMsg_EncryptedData} message CSVCMsg_EncryptedData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_EncryptedData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encrypted = "";
                else {
                    object.encrypted = [];
                    if (options.bytes !== Array)
                        object.encrypted = $util.newBuffer(object.encrypted);
                }
                object.key_type = 0;
            }
            if (message.encrypted != null && message.hasOwnProperty("encrypted"))
                object.encrypted = options.bytes === String ? $util.base64.encode(message.encrypted, 0, message.encrypted.length) : options.bytes === Array ? Array.prototype.slice.call(message.encrypted) : message.encrypted;
            if (message.key_type != null && message.hasOwnProperty("key_type"))
                object.key_type = message.key_type;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_EncryptedData to JSON.
         * @function toJSON
         * @memberof CSVCMsg_EncryptedData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_EncryptedData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_EncryptedData;
    })();
    
    $root.CSVCMsg_HltvReplay = (function() {
    
        /**
         * Properties of a CSVCMsg_HltvReplay.
         * @exports ICSVCMsg_HltvReplay
         * @interface ICSVCMsg_HltvReplay
         * @property {number|null} [delay] CSVCMsg_HltvReplay delay
         * @property {number|null} [primary_target] CSVCMsg_HltvReplay primary_target
         * @property {number|null} [replay_stop_at] CSVCMsg_HltvReplay replay_stop_at
         * @property {number|null} [replay_start_at] CSVCMsg_HltvReplay replay_start_at
         * @property {number|null} [replay_slowdown_begin] CSVCMsg_HltvReplay replay_slowdown_begin
         * @property {number|null} [replay_slowdown_end] CSVCMsg_HltvReplay replay_slowdown_end
         * @property {number|null} [replay_slowdown_rate] CSVCMsg_HltvReplay replay_slowdown_rate
         */
    
        /**
         * Constructs a new CSVCMsg_HltvReplay.
         * @exports CSVCMsg_HltvReplay
         * @classdesc Represents a CSVCMsg_HltvReplay.
         * @implements ICSVCMsg_HltvReplay
         * @constructor
         * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
         */
        function CSVCMsg_HltvReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_HltvReplay delay.
         * @member {number} delay
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.delay = 0;
    
        /**
         * CSVCMsg_HltvReplay primary_target.
         * @member {number} primary_target
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.primary_target = 0;
    
        /**
         * CSVCMsg_HltvReplay replay_stop_at.
         * @member {number} replay_stop_at
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replay_stop_at = 0;
    
        /**
         * CSVCMsg_HltvReplay replay_start_at.
         * @member {number} replay_start_at
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replay_start_at = 0;
    
        /**
         * CSVCMsg_HltvReplay replay_slowdown_begin.
         * @member {number} replay_slowdown_begin
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replay_slowdown_begin = 0;
    
        /**
         * CSVCMsg_HltvReplay replay_slowdown_end.
         * @member {number} replay_slowdown_end
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replay_slowdown_end = 0;
    
        /**
         * CSVCMsg_HltvReplay replay_slowdown_rate.
         * @member {number} replay_slowdown_rate
         * @memberof CSVCMsg_HltvReplay
         * @instance
         */
        CSVCMsg_HltvReplay.prototype.replay_slowdown_rate = 0;
    
        /**
         * Creates a new CSVCMsg_HltvReplay instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay instance
         */
        CSVCMsg_HltvReplay.create = function create(properties) {
            return new CSVCMsg_HltvReplay(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvReplay message. Does not implicitly {@link CSVCMsg_HltvReplay.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay} message CSVCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.delay != null && message.hasOwnProperty("delay"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.delay);
            if (message.primary_target != null && message.hasOwnProperty("primary_target"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.primary_target);
            if (message.replay_stop_at != null && message.hasOwnProperty("replay_stop_at"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.replay_stop_at);
            if (message.replay_start_at != null && message.hasOwnProperty("replay_start_at"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.replay_start_at);
            if (message.replay_slowdown_begin != null && message.hasOwnProperty("replay_slowdown_begin"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.replay_slowdown_begin);
            if (message.replay_slowdown_end != null && message.hasOwnProperty("replay_slowdown_end"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.replay_slowdown_end);
            if (message.replay_slowdown_rate != null && message.hasOwnProperty("replay_slowdown_rate"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.replay_slowdown_rate);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_HltvReplay message, length delimited. Does not implicitly {@link CSVCMsg_HltvReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {ICSVCMsg_HltvReplay} message CSVCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_HltvReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.delay = reader.int32();
                    break;
                case 2:
                    message.primary_target = reader.int32();
                    break;
                case 3:
                    message.replay_stop_at = reader.int32();
                    break;
                case 4:
                    message.replay_start_at = reader.int32();
                    break;
                case 5:
                    message.replay_slowdown_begin = reader.int32();
                    break;
                case 6:
                    message.replay_slowdown_end = reader.int32();
                    break;
                case 7:
                    message.replay_slowdown_rate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_HltvReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_HltvReplay message.
         * @function verify
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_HltvReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.delay != null && message.hasOwnProperty("delay"))
                if (!$util.isInteger(message.delay))
                    return "delay: integer expected";
            if (message.primary_target != null && message.hasOwnProperty("primary_target"))
                if (!$util.isInteger(message.primary_target))
                    return "primary_target: integer expected";
            if (message.replay_stop_at != null && message.hasOwnProperty("replay_stop_at"))
                if (!$util.isInteger(message.replay_stop_at))
                    return "replay_stop_at: integer expected";
            if (message.replay_start_at != null && message.hasOwnProperty("replay_start_at"))
                if (!$util.isInteger(message.replay_start_at))
                    return "replay_start_at: integer expected";
            if (message.replay_slowdown_begin != null && message.hasOwnProperty("replay_slowdown_begin"))
                if (!$util.isInteger(message.replay_slowdown_begin))
                    return "replay_slowdown_begin: integer expected";
            if (message.replay_slowdown_end != null && message.hasOwnProperty("replay_slowdown_end"))
                if (!$util.isInteger(message.replay_slowdown_end))
                    return "replay_slowdown_end: integer expected";
            if (message.replay_slowdown_rate != null && message.hasOwnProperty("replay_slowdown_rate"))
                if (typeof message.replay_slowdown_rate !== "number")
                    return "replay_slowdown_rate: number expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_HltvReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
         */
        CSVCMsg_HltvReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_HltvReplay)
                return object;
            var message = new $root.CSVCMsg_HltvReplay();
            if (object.delay != null)
                message.delay = object.delay | 0;
            if (object.primary_target != null)
                message.primary_target = object.primary_target | 0;
            if (object.replay_stop_at != null)
                message.replay_stop_at = object.replay_stop_at | 0;
            if (object.replay_start_at != null)
                message.replay_start_at = object.replay_start_at | 0;
            if (object.replay_slowdown_begin != null)
                message.replay_slowdown_begin = object.replay_slowdown_begin | 0;
            if (object.replay_slowdown_end != null)
                message.replay_slowdown_end = object.replay_slowdown_end | 0;
            if (object.replay_slowdown_rate != null)
                message.replay_slowdown_rate = Number(object.replay_slowdown_rate);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_HltvReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_HltvReplay
         * @static
         * @param {CSVCMsg_HltvReplay} message CSVCMsg_HltvReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_HltvReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.delay = 0;
                object.primary_target = 0;
                object.replay_stop_at = 0;
                object.replay_start_at = 0;
                object.replay_slowdown_begin = 0;
                object.replay_slowdown_end = 0;
                object.replay_slowdown_rate = 0;
            }
            if (message.delay != null && message.hasOwnProperty("delay"))
                object.delay = message.delay;
            if (message.primary_target != null && message.hasOwnProperty("primary_target"))
                object.primary_target = message.primary_target;
            if (message.replay_stop_at != null && message.hasOwnProperty("replay_stop_at"))
                object.replay_stop_at = message.replay_stop_at;
            if (message.replay_start_at != null && message.hasOwnProperty("replay_start_at"))
                object.replay_start_at = message.replay_start_at;
            if (message.replay_slowdown_begin != null && message.hasOwnProperty("replay_slowdown_begin"))
                object.replay_slowdown_begin = message.replay_slowdown_begin;
            if (message.replay_slowdown_end != null && message.hasOwnProperty("replay_slowdown_end"))
                object.replay_slowdown_end = message.replay_slowdown_end;
            if (message.replay_slowdown_rate != null && message.hasOwnProperty("replay_slowdown_rate"))
                object.replay_slowdown_rate = options.json && !isFinite(message.replay_slowdown_rate) ? String(message.replay_slowdown_rate) : message.replay_slowdown_rate;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_HltvReplay to JSON.
         * @function toJSON
         * @memberof CSVCMsg_HltvReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_HltvReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_HltvReplay;
    })();
    
    $root.CCLCMsg_HltvReplay = (function() {
    
        /**
         * Properties of a CCLCMsg_HltvReplay.
         * @exports ICCLCMsg_HltvReplay
         * @interface ICCLCMsg_HltvReplay
         * @property {number|null} [request] CCLCMsg_HltvReplay request
         * @property {number|null} [slowdown_length] CCLCMsg_HltvReplay slowdown_length
         * @property {number|null} [slowdown_rate] CCLCMsg_HltvReplay slowdown_rate
         * @property {number|null} [primary_target_ent_index] CCLCMsg_HltvReplay primary_target_ent_index
         * @property {number|null} [event_time] CCLCMsg_HltvReplay event_time
         */
    
        /**
         * Constructs a new CCLCMsg_HltvReplay.
         * @exports CCLCMsg_HltvReplay
         * @classdesc Represents a CCLCMsg_HltvReplay.
         * @implements ICCLCMsg_HltvReplay
         * @constructor
         * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
         */
        function CCLCMsg_HltvReplay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CCLCMsg_HltvReplay request.
         * @member {number} request
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.request = 0;
    
        /**
         * CCLCMsg_HltvReplay slowdown_length.
         * @member {number} slowdown_length
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.slowdown_length = 0;
    
        /**
         * CCLCMsg_HltvReplay slowdown_rate.
         * @member {number} slowdown_rate
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.slowdown_rate = 0;
    
        /**
         * CCLCMsg_HltvReplay primary_target_ent_index.
         * @member {number} primary_target_ent_index
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.primary_target_ent_index = 0;
    
        /**
         * CCLCMsg_HltvReplay event_time.
         * @member {number} event_time
         * @memberof CCLCMsg_HltvReplay
         * @instance
         */
        CCLCMsg_HltvReplay.prototype.event_time = 0;
    
        /**
         * Creates a new CCLCMsg_HltvReplay instance using the specified properties.
         * @function create
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay instance
         */
        CCLCMsg_HltvReplay.create = function create(properties) {
            return new CCLCMsg_HltvReplay(properties);
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvReplay message. Does not implicitly {@link CCLCMsg_HltvReplay.verify|verify} messages.
         * @function encode
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay} message CCLCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvReplay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.request != null && message.hasOwnProperty("request"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.request);
            if (message.slowdown_length != null && message.hasOwnProperty("slowdown_length"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.slowdown_length);
            if (message.slowdown_rate != null && message.hasOwnProperty("slowdown_rate"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.slowdown_rate);
            if (message.primary_target_ent_index != null && message.hasOwnProperty("primary_target_ent_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.primary_target_ent_index);
            if (message.event_time != null && message.hasOwnProperty("event_time"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.event_time);
            return writer;
        };
    
        /**
         * Encodes the specified CCLCMsg_HltvReplay message, length delimited. Does not implicitly {@link CCLCMsg_HltvReplay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {ICCLCMsg_HltvReplay} message CCLCMsg_HltvReplay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CCLCMsg_HltvReplay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.
         * @function decode
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvReplay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.request = reader.int32();
                    break;
                case 2:
                    message.slowdown_length = reader.float();
                    break;
                case 3:
                    message.slowdown_rate = reader.float();
                    break;
                case 4:
                    message.primary_target_ent_index = reader.int32();
                    break;
                case 5:
                    message.event_time = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CCLCMsg_HltvReplay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CCLCMsg_HltvReplay message.
         * @function verify
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CCLCMsg_HltvReplay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.request != null && message.hasOwnProperty("request"))
                if (!$util.isInteger(message.request))
                    return "request: integer expected";
            if (message.slowdown_length != null && message.hasOwnProperty("slowdown_length"))
                if (typeof message.slowdown_length !== "number")
                    return "slowdown_length: number expected";
            if (message.slowdown_rate != null && message.hasOwnProperty("slowdown_rate"))
                if (typeof message.slowdown_rate !== "number")
                    return "slowdown_rate: number expected";
            if (message.primary_target_ent_index != null && message.hasOwnProperty("primary_target_ent_index"))
                if (!$util.isInteger(message.primary_target_ent_index))
                    return "primary_target_ent_index: integer expected";
            if (message.event_time != null && message.hasOwnProperty("event_time"))
                if (typeof message.event_time !== "number")
                    return "event_time: number expected";
            return null;
        };
    
        /**
         * Creates a CCLCMsg_HltvReplay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
         */
        CCLCMsg_HltvReplay.fromObject = function fromObject(object) {
            if (object instanceof $root.CCLCMsg_HltvReplay)
                return object;
            var message = new $root.CCLCMsg_HltvReplay();
            if (object.request != null)
                message.request = object.request | 0;
            if (object.slowdown_length != null)
                message.slowdown_length = Number(object.slowdown_length);
            if (object.slowdown_rate != null)
                message.slowdown_rate = Number(object.slowdown_rate);
            if (object.primary_target_ent_index != null)
                message.primary_target_ent_index = object.primary_target_ent_index | 0;
            if (object.event_time != null)
                message.event_time = Number(object.event_time);
            return message;
        };
    
        /**
         * Creates a plain object from a CCLCMsg_HltvReplay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CCLCMsg_HltvReplay
         * @static
         * @param {CCLCMsg_HltvReplay} message CCLCMsg_HltvReplay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CCLCMsg_HltvReplay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.request = 0;
                object.slowdown_length = 0;
                object.slowdown_rate = 0;
                object.primary_target_ent_index = 0;
                object.event_time = 0;
            }
            if (message.request != null && message.hasOwnProperty("request"))
                object.request = message.request;
            if (message.slowdown_length != null && message.hasOwnProperty("slowdown_length"))
                object.slowdown_length = options.json && !isFinite(message.slowdown_length) ? String(message.slowdown_length) : message.slowdown_length;
            if (message.slowdown_rate != null && message.hasOwnProperty("slowdown_rate"))
                object.slowdown_rate = options.json && !isFinite(message.slowdown_rate) ? String(message.slowdown_rate) : message.slowdown_rate;
            if (message.primary_target_ent_index != null && message.hasOwnProperty("primary_target_ent_index"))
                object.primary_target_ent_index = message.primary_target_ent_index;
            if (message.event_time != null && message.hasOwnProperty("event_time"))
                object.event_time = options.json && !isFinite(message.event_time) ? String(message.event_time) : message.event_time;
            return object;
        };
    
        /**
         * Converts this CCLCMsg_HltvReplay to JSON.
         * @function toJSON
         * @memberof CCLCMsg_HltvReplay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CCLCMsg_HltvReplay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CCLCMsg_HltvReplay;
    })();
    
    $root.CSVCMsg_Broadcast_Command = (function() {
    
        /**
         * Properties of a CSVCMsg_Broadcast_Command.
         * @exports ICSVCMsg_Broadcast_Command
         * @interface ICSVCMsg_Broadcast_Command
         * @property {string|null} [cmd] CSVCMsg_Broadcast_Command cmd
         */
    
        /**
         * Constructs a new CSVCMsg_Broadcast_Command.
         * @exports CSVCMsg_Broadcast_Command
         * @classdesc Represents a CSVCMsg_Broadcast_Command.
         * @implements ICSVCMsg_Broadcast_Command
         * @constructor
         * @param {ICSVCMsg_Broadcast_Command=} [properties] Properties to set
         */
        function CSVCMsg_Broadcast_Command(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CSVCMsg_Broadcast_Command cmd.
         * @member {string} cmd
         * @memberof CSVCMsg_Broadcast_Command
         * @instance
         */
        CSVCMsg_Broadcast_Command.prototype.cmd = "";
    
        /**
         * Creates a new CSVCMsg_Broadcast_Command instance using the specified properties.
         * @function create
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command=} [properties] Properties to set
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command instance
         */
        CSVCMsg_Broadcast_Command.create = function create(properties) {
            return new CSVCMsg_Broadcast_Command(properties);
        };
    
        /**
         * Encodes the specified CSVCMsg_Broadcast_Command message. Does not implicitly {@link CSVCMsg_Broadcast_Command.verify|verify} messages.
         * @function encode
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Broadcast_Command.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            return writer;
        };
    
        /**
         * Encodes the specified CSVCMsg_Broadcast_Command message, length delimited. Does not implicitly {@link CSVCMsg_Broadcast_Command.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {ICSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSVCMsg_Broadcast_Command.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CSVCMsg_Broadcast_Command message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Broadcast_Command.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Broadcast_Command();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmd = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CSVCMsg_Broadcast_Command message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSVCMsg_Broadcast_Command.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CSVCMsg_Broadcast_Command message.
         * @function verify
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSVCMsg_Broadcast_Command.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            return null;
        };
    
        /**
         * Creates a CSVCMsg_Broadcast_Command message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CSVCMsg_Broadcast_Command} CSVCMsg_Broadcast_Command
         */
        CSVCMsg_Broadcast_Command.fromObject = function fromObject(object) {
            if (object instanceof $root.CSVCMsg_Broadcast_Command)
                return object;
            var message = new $root.CSVCMsg_Broadcast_Command();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            return message;
        };
    
        /**
         * Creates a plain object from a CSVCMsg_Broadcast_Command message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CSVCMsg_Broadcast_Command
         * @static
         * @param {CSVCMsg_Broadcast_Command} message CSVCMsg_Broadcast_Command
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CSVCMsg_Broadcast_Command.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cmd = "";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            return object;
        };
    
        /**
         * Converts this CSVCMsg_Broadcast_Command to JSON.
         * @function toJSON
         * @memberof CSVCMsg_Broadcast_Command
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CSVCMsg_Broadcast_Command.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CSVCMsg_Broadcast_Command;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && message.hasOwnProperty("start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && message.hasOwnProperty("end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && message.hasOwnProperty("number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {string}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {string}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && message.hasOwnProperty("number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {string}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {string|null} [experimental_map_key] FieldOptions experimental_map_key
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions experimental_map_key.
                 * @member {string} experimental_map_key
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.experimental_map_key = "";
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.experimental_map_key);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 9:
                            message.experimental_map_key = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        if (!$util.isString(message.experimental_map_key))
                            return "experimental_map_key: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.experimental_map_key != null)
                        message.experimental_map_key = String(object.experimental_map_key);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.experimental_map_key = "";
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.experimental_map_key != null && message.hasOwnProperty("experimental_map_key"))
                        object.experimental_map_key = message.experimental_map_key;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {string}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
